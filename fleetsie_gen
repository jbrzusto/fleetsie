#!/bin/bash

# fleetsiegen - create a template provisioning disk for fleetsie,
# and the fleet inventory on the fleet server.

function usage () {
    # usage below is copied from the `fleetsie_gen` section of README.md
    cat <<EOF
## 'fleetsie_gen' - generate a USB provisioning disk and server inventory
for a fleet of devices.

Usage:

   fleetsie_gen FLEET_NAME FLEET_HOST [NUM] [USB_PARTITION]

where

   FLEET_NAME is the name of the fleet.  It should be short and
   composed of alphanumeric characters and underscores.  Devices
   belonging to the fleet will be assigned the hostnames FLEET_NAME-1,
   FLEET_NAME-2, ...

   FLEET_HOST is the server (e.g. whoflewby.org) where the fleet
   will be hosted.  The user running fleetsie_gen must have ssh set-up
   so that they can login to fleetsie@FLEET_HOST

   NUM (optional) is the number of devices to pre-allocate for the
   fleet on the server.  If this is zero or missing, no devices are
   pre-allocated.  Otherwise, SIZE new devices are allocated for the
   fleet, adding to any which are already there.  e.g. if the fleet
   already has 100 device allocated (from a previous use of
   fleetsie_gen), the new devices will be named FLEET-101, FLEET-102,
   ...

   USB_PARTITION (optional) is the name of the disk partition on the
   user's machine (e.g. sda2) where the fleetsie files will be installed.
   If missing, no fleet files are installed anywhere; this allows you
   to just allocate new fleet devices on the server without creating
   a USB disk.

   If USB_PARTITION begins with a "/", it is treated as a path to a
   directory, and fleetsie_gen will create or use a subdirectory there
   called "fleetsie" as the destination for installing files, rather
   than a disk partition. This can be used for testing.  Otherwise,
   it must be the name of a device with a disk partition where you
   want to create/update the fleetsie provisioning folder.
   e.g. "sda1"

   If USB_PARTITION is supplied, fleetsie_gen also writes a zip file
   called FLEET_files_for_usb_disk.zip, which can be shared with
   device provisioners. They can then extract the zip file to the
   top-level folder of their own USB drive.

   If both NUM and USB_PARTITION are missing, fleetsie_gen verifies
   that it can ssh as fleetsie@FLEET_HOST, then exits.

fleetsie_gen creates files on a USB drive and on the fleet server such
that a number of devices can be provisioned (using the USB drive) with
access to the server.

USB drive layout
fleetsie_gen creates this layout on the USB drive:

  /fleetsie
   - top-level folder

  /fleetsie/wifi.txt

   - file containing essids and passwords for wifi networks, one per
     line i.e. line 1 = ESSID1, line 2 = password1, line 3 = ESSID2,
     line 3 = password2, ...  During provisioning, the device will
     attempt to connect to wifi using these credentials, one set at a
     time, until a connection succeeds.

  /fleetsie/fleet.txt

   - line 1: fleet hostname (e.g. whoflewby.org)
   - line 2: fleet name (e.g. ampi)
   - line 3: line from ~/.ssh/known_hosts for host in line 1

  /fleetsie/fleetsieauth.pub
  /fleetsie/fleetsieauth

   - ssh keys used to login to the fleet server at provisioning time; on the server,
     ssh is configured so that logging in with these keys runs the server-side
     provisioning code.  No other use for these keys is permitted by the server.

  /fleetsie/ssh-tunnel.service
  /fleetsie/ssh_tunnel.sh

   - systemd service and script it runs to maintain a ssh connection to the fleet server,
     with a port mapped from the server back to the local ssh server; also maintains
     a local port which maps to the zabbix data port on the fleet server.

  /fleetsie/custom

   - the custom folder is reserved for your customizations.  Three filenames there
     have special meaning:  'setup', 'overlay.tar.xz' and 'cleanup'.
     fleetsie_provision ignores all other files and subdirectories in /fleetsie/custom.

EOF
    exit 1
}

function die () {
    printf "$*\n"
    exit 1
}

function die_with_usage () {
    printf "$*\n"
    usage
}

# get_arg saves $1 into the named parameter,
# or dies with an error message.
function get_arg () {
    declare -n v=$1
    shift
    if [[ "$1" == "" ]]; then
	die_with_usage missing parameter $1
    fi
    v=$1
}

get_arg FLEET_NAME "$@"
shift

get_arg FLEET_HOST "$@"
shift

if ! ssh -v fleetsie@$FLEET_HOST date 2>/tmp/errmsg.txt 1>&2; then
    die "unable to ssh to fleetsie@$FLEET_HOST: " "`cat /tmp/errmsg.txt`"
fi

if [[ ! "$1" ]]; then
    printf "ssh to fleetsie@$FLEET_HOST succeeded\n" >&2
    exit 0
fi
if [[ "$1" =~ ^[0-9]+$ ]]; then
    NUM=$1
    shift
fi
USB_PARTITION="$1"

# get the absolute path to the directory fleetsie_gen was run from
FLEETSIE_DIR=`dirname $0`
FLEETSIE_DIR=`cd $FLEETSIE_DIR && pwd`

# run the server-side fleetsie_gen_server script, even if $NUM==0,
# because it also syncs databases
printf "Adding $NUM devices to fleet $FLEET_NAME and syncing DBs\n"
if ! ssh -t fleetsie@$FLEET_HOST ./fleetsie_gen_server $NUM $FLEET_NAME; then
    ssh -t fleetsie@$FLEET_HOST ./fleetsie_gen_server $NUM $FLEET_NAME
fi

if [[ "$USB_PARTITION" != "" ]]; then
    # determine the target directory for the provisioning files
    if [[ "${USB_PARTITION:0:1}" == "/" ]]; then
	PARTITIONISDIR=1
	if [[ ! -d "$USB_PARTITION" ]]; then
	    die "error: '$USB_PARTITION' is not a valid directory"
	else
	    TARGET="$USB_PARTITION"
	fi
    else if ! grep " $USB_PARTITION$" /proc/partitions > /dev/null; then
	     die "error: '$USB_PARTITION' is not a valid disk partition"
	 else
	     usbdev="/dev/$USB_PARTITION"
	     TARGET=`findmnt -no TARGET "$usbdev"`
	     if [[ ! "$TARGET" ]]; then
		 TARGET=`mktemp`
		 if ! mount $usbdev $TARGET; then
		     rmdir $TARGET
		     die "unable to mount partition $usbdev at $TARGET"
		 fi
	     fi
	 fi
    fi
    # create fleetsie dir and files
    PROVDIR="$TARGET/fleetsie"
    FLEETSUBDIR=/home/fleetsie/fleets/$FLEET_NAME
    # create both top-level fleetsie directory and the 'custom' subdirectory
    mkdir -p "$PROVDIR/cusom"
    # fleet file, with fleet host, flee name and known_hosts entry for the fleet host
    KNOWNHOSTS=`ssh-keyscan -t ed25519 -H $FLEET_HOST  2>/dev/null`
    printf "%s\r\n%s\r\n" "$FLEET_HOST" "$FLEET_NAME" "$KNOWNHOSTS" > "$PROVDIR/fleet.txt"

    # wifi credentials file, with alternating lines of ESSID, passphrase
    printf "%s\r\n%s\r\n" "replace_with_wifi_network_name" "replace_with_wifi_password" > "$PROVDIR/wifi.txt"

    # provisioning db
    PROVISIONING_DB="$FLEETSUBDIR/provisioning.sqlite"
    scp fleetsie@$FLEET_HOST:$PROVISIONING_DB "$PROVDIR/provisioning.sqlite"

    # fleet credentials, for sending OTP to obtain device credentials
    FLEET_CREDS="$FLEETSUBDIR/id_ed25519_provision_$FLEET_NAME"
    scp fleetsie@$FLEET_HOST:$FLEET_CREDS* "$PROVDIR"

    # copy ssh tunnel service and script
    cp ./ssh-tunnel.service ./ssh_tunnel.sh "$PROVDIR"

    # generate a .zip file with the contents of the USB partition, so others
    # can create their own disk
    USB_FILES_FOR_DISK=`pwd`/${FLEET_NAME}_files_for_usb_disk.zip
    pushd $USB_PARTITION && zip -r $USB_FILES_FOR_DISK . && popd

    cat <<EOF
*** Provisioning to $USB_PARTITION is complete. ***

You can further customize the provisioning disk by adding files
and/or directories to the 'fleetsie/custom' subdirectory:

 - setup script:

     Add a script called 'setup' to the directory.  It will be run as root on
     the device after it has obtained credentials for the fleet
     server.  It is run from the `fleetsie/custom` directory on the provisioning disk.

 - overlay archive:

     Add an xz-compressed tar archive called 'overlay.tar.xz' to the directory.
     It will be extracted at the root directory ("/") of the device after
     the 'setup' script has run.

 - cleanup script:

     Add a script called 'cleanup' to the directory.  It will be run on
     the device after any 'setup' script has been run and after any overlay
     archive has been extracted.
EOF
    if [[ ! $PARTITIONISDIR ]]; then
	cat <<EOF
Your partition $USB_PARTITION is currently mounted at $TARGET, where the
fleetsie directory has been created.

Make sure to unmount $USB_PARTITION before removing the drive.

A copy of the files for the USB disk has been created in

   $USB_FILES_FOR_DISK

You can share this with others so they can create their own provisioning
USB disk by unzipping the contents to the top level of their own USB drive.
If you customize, make sure to update the .zip archive like so:

   pushd $USB_PARTITION && zip -r $USB_FILES_FOR_DISK . && popd

EOF
    fi
fi
