#!/bin/bash

# fleetsiegen - create a template provisioning disk for fleetsie,
# and the fleet inventory on the fleet server.

function usage () {
    # usage below is copied from the `fleetsie_gen` section of README.md
    cat <<EOF
## 'fleetsie_gen' - generate a USB provisioning disk and server inventory
for a fleet of devices.

Usage:

   fleetsie_gen FLEET_NAME FLEET_HOST [NUM] [USB_PARTITION]

where

   FLEET_NAME is the name of the fleet.  It should be short and
   composed of alphanumeric characters and underscores.  Devices
   belonging to the fleet will be assigned the hostnames FLEET_NAME-1,
   FLEET_NAME-2, ...

   FLEET_HOST is the server (e.g. whoflewby.org) where the fleet
   will be hosted.  The user running fleetsie_gen must have ssh set-up
   so that they can login to fleetsie@FLEET_HOST

   NUM (optional) is the number of devices to pre-allocate for the
   fleet on the server.  If this is zero or missing, no devices are
   pre-allocated.  Otherwise, SIZE new devices are allocated for the
   fleet, adding to any which are already there.  e.g. if the fleet
   already has 100 device allocated (from a previous use of
   fleetsie_gen), the new devices will be named FLEET-101, FLEET-102,
   ...

   USB_PARTITION (optional) is the name of the disk partition on the
   user's machine (e.g. sda2) where the fleetsie files will be installed.
   If missing, no fleet files are installed anywhere; this allows you
   to just allocate new fleet devices on the server without creating
   a USB disk.

   If USB_PARTITION begins with a "/", it is treated as a path to a
   directory, and fleetsie_gen will create or use a subdirectory there
   called "fleetsie" as the destination for installing files, rather
   than a disk partition. This can be used for testing.

   If both NUM and USB_PARTITION are missing, fleetsie_gen verifies
   that it can ssh as fleetsie@FLEET_HOST, then exits.

fleetsie_gen creates files on a USB drive and on the fleet server such
that a number of devices can be provisioned (using the USB drive) with
access to the server.

USB drive layout
fleetsie_gen creates this layout on the USB drive:

  /fleetsie
   - top-level folder

  /fleetsie/wifi.txt

   - file containing essids and passwords for wifi networks, one per
     line i.e. line 1 = ESSID1, line 2 = password1, line 3 = ESSID2,
     line 3 = password2, ...  During provisioning, the device will
     attempt to connect to wifi using these credentials, one set at a
     time, until a connection succeeds.

  /fleetsie/fleet.txt

   - file containing the fleet hostname on line 1, and the fleet name on line 2

  /fleetsie/fleetsieauth.pub
  /fleetsie/fleetsieauth

   - ssh keys used to login to the fleet server at provisioning time; on the server,
     ssh is configured so that logging in with these keys runs the server-side
     provisioning code.  No other use for these keys is permitted by the server.

  /fleetsie/ssh-tunnel.service
  /fleetsie/ssh_tunnel.sh

   - systemd service and script it runs to maintain a ssh connection to the fleet server,
     with a port mapped from the server back to the local ssh server; also maintains
     a local port which maps to the zabbix data port on the fleet server.

  /fleetsie/custom/setup

   - the custom folder is where fleetsie looks for other files you want to install.
     The setup script will be run after all other provisioning steps have succeeded.
     fleetsie ignores all other files and subdirectories of /fleetsie/custom.

EOF
    exit 1
}

function die () {
    printf "$*\n"
    exit 1
}

function die_with_usage () {
    printf "$*\n"
    usage
}

# get_arg saves $1 into the named parameter,
# or dies with an error message.
function get_arg () {
    declare -n v=$1
    if [[ ! "$1" ]]; then
	die_with_usage missing parameter $1
    fi
    $v=$1
    shift
}

get_arg FLEET_NAME
get_arg FLEET_HOST
if ! ssh -v fleetsie@$FLEET_HOST date 2>/tmp/errmsg.txt 1>&2; then
    die "unable to ssh to fleetsie@$FLEET_HOST: " "`cat /tmp/errmsg.txt`"
fi

if [[ ! "$1" ]]; then
    printf "ssh to fleetsie@$FLEET_HOST succeeded\n" >&2
    exit 0
fi
if [[ "$1" =~ ^[0-9]+$ ]]; then
    NUM=$1
    shift
fi
USB_PARTITION=$1

# if NUM > 0, we generate N new devices for the fleet.  This is done by running
# a script on the server, then fetching the client version of the table for the fleet
if [[ $NUM -gt 0 ]]; then
    printf "Adding $NUM devices to fleet $FLEET_NAME\n"
    ssh fleetsie@$FLEET_HOST ./fleetsie_gen_server $FLEET_NAME $NUM
    scp fleetsie@$FLEET_HOST /home/fleetsie_$FLEET_NAME/provisioning


## separate host side from client side
coproc SQL { sqlite3 -column $CONFIG_DB 2>&1; }
FROMSQL=${SQL[0]}
TOSQL=${SQL[1]}
sleep 0.1
printf ".prompt \"\" \"\"\n" >&$TOSQL
printf ".timeout 1000\n" >&$TOSQL
read -t 0.1 ignore <&$FROMSQL
read -t 0.1 ignore <&$FROMSQL
# do_cmd runs a command in the attached sqlite database
do_cmd() {
    printf "%s;\n" "$1" >&$TOSQL
}

# notes on what the db looks like
# create table devices (
#     id integer unique primary key not null,
#     fleet string,
#     fleetuser string,
#     hostname string,
#     hwid string,
#     otp string,
#     ts_generated double,
#     ts_provisioned double,
#     tunnel_port integer,
#     public_key string,
#     private_key string,
#     ip_provisioned_from
# );
# create unique index on devices(hwid);
# create unique index on devices(fleet,otp,hwid);

# Entries in this table are created by fleetsie_gen.  For each entry, the missing fields are
# ts_provisioned, ip_provisioned_from, and hwid.  These are determined by the provisioning
# race.
