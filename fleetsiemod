#!/bin/bash

# fleetsiemod - manage the creation of a modified OS image to be used for the fleet

function usage () {
    # usage below is copied from the `fleetsiemod` section of README.md
    cat <<EOF
## 'fleetsiemod' - Manage Creation of a Modified OS Image

### Commands:

  fleetsiemod init PATH/OSNAME.img.xz

- decompresses the image using xz and writes it to file OSNAME.img in the current directory
- mounts all partitions in the image, as is done by the 'fleetsie mount' command below
- creates a symlink from '.image -> OSNAME.img'
- initializes a git repo in 'my_work', where overlays for each of the partitions in 'OSNAME.img'
will be created, so that you can use version control to track your work.

  fleetsiemod mount

- mounts each partition in 'OSNAME.img' read-only to directory 'original/part_N'
- creates an overlay mount for each partition; the merged mount is in 'part_N', where N is 1, 2, ...
- changes to the underlying image will be reflected in directories '.new_N'; these are created
if they do not already exist.
- symlinks are created from the underlying partition labels to part_N; e.g. 'bootfs -> part_1'

  fleetsiemod unmount

- unmounts the merged and original filesystems
- changes made remain available in the '.new_N' directories and will be
automatically restored the next time 'fleetsie mount OSNAME.img' is run

  fleetsiemod install [OSTYPE]

- uses instructions customized for 'OSTYPE' to install 'fleetsie' in the overlain OS image.
- 'OSTYPE' defaults to 'Raspberry Pi OS'; do 'fleetsiemod install --help' to list others.
- after this command, you can make any further customizations to the image by manipulating files
in the 'part_N' directories
- do 'fleetsiemod save' to create a new installable image that includes 'fleetsie' and your changes

  fleetsiemod save [NEW_IMAGE_NAME]
- writes the filesystem with your changes to a new, xz-compressed image
- if 'NEW_IMAGE_NAME' is omitted, it defaults to 'OSNAME_fleetsie.img',
- normally, you would only do 'fleetsiemod save' after doing 'fleetsiemod install'
and, optionally, making further changes to the 'part_N' directories
EOF
    exit 1
}

# make_part_names defines symbols for
# partitions/dirs used in mergerfs.
# it is passed an integer 1...9 as $1
function make_part_names () {
    orig_main=original
    merged_main=merged
    upper_main=my_work
    orig=${orig_main}/part_$1
    merged=${merged_main}/part_$1
    upper=${upper_main}/part_$1
}

# get_num_parts sets np to the number of partitions
# in the image passed as $1
function get_num_parts () {
    np=`sudo kpartx -l $1 | wc -l`
}

function init_image () {
    if [[ ! "$1" =~ .img.xz$ ]]; then
	echo "this doesn't look like an xz-compressed image file: $1"
	exit 1
    fi
    image=`basename "$1"`
    image=./${image%.xz}
    echo Decompressing to "./$image"
    xz -v --decompress --stdout "$1" > "$image"
    ln -s "$image" .image
    make_part_names 1
    if [[ ! -d $upper_main ]]; then
	git init $upper_main
	printf "This directory holds overlain changes to partitions from `basename \"$image\"`\n" > $upper_main/README.md
	printf "Created new git repo for your changes work in %s\n" $upper_main
    fi
    mount_image
}

function get_image_name () {
    if [[ -L .image ]]; then
	image=`readlink .image`
	return
    fi
    printf "Error: you need to use fleetsiemod init ... to start working on an image\n"
    exit 1
}

function mount_image () {
    get_image_name
    echo Mounting partitions in "$image"
    i=1
    for x in `sudo kpartx -av "$image" | awk '{print $3}'`; do
	make_part_names $i
	mkdir -p $orig $merged $upper
	sudo mount -o ro /dev/mapper/$x $orig
	pname=`sudo blkid -s LABEL -o value  /dev/mapper/$x`
	sudo mergerfs -o defaults,allow_other,use_ino,category.create=epmfs $orig:$upper $merged
	rm -f $pname
	ln -s $merged $pname
	echo -n "$pname: " && grep $merged /etc/mtab
	i=$(( $i + 1 ))
    done
}

function unmount_image () {
    get_image_name
    get_num_parts $image
    for i in `seq 1 $np`; do
	make_part_names $image
	sudo umount $merged
	sudo umount $orig
    done
    sudo kpartx -dv $image
}

verb=$1
shift
case $verb in
    init) if [[ "$1" == "" ]]; then
	      usage
	  fi
	  init_image "$*"
	  ;;
    mount) if [[ "$1" == "" ]]; then
	       usage
	   fi
	   mount_image "$*"
	   ;;
    unmount) if [[ "$1" == "" ]]; then
	      usage
	  fi
	  unmount_image "$*"
	  ;;
    *) usage
	;;
esac
