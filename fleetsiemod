#!/bin/bash

# fleetsiemod - manage the creation of a modified OS image to be used for the fleet

function usage () {
    # usage below is copied from the `fleetsiemod` section of README.md
    cat <<EOF
## 'fleetsiemod' - Manage Creation of a Modified OS Image

### Commands:

  fleetsiemod init PATH/OSNAME.img.xz

- decompresses the image using xz and writes it to file OSNAME.img in the current directory
- mounts all partitions in the image, as is done by the 'fleetsie mount' command below
- creates a symlink from '.image -> OSNAME.img'
- initializes a git repo in 'my_work', where overlays for each of the partitions in 'OSNAME.img'
will be created, so that you can use version control to track your work.

  fleetsiemod mount

- mounts each partition in 'OSNAME.img' read-only to directory 'original/part_N'
- creates an overlay mount for each partition; the merged mount is in 'part_N', where N is 1, 2, ...
- changes to the underlying image will be reflected in directories '.new_N'; these are created
if they do not already exist.
- symlinks are created from the underlying partition labels to part_N; e.g. 'bootfs -> part_1'

  fleetsiemod unmount

- unmounts the merged and original filesystems
- changes made remain available in the '.new_N' directories and will be
automatically restored the next time 'fleetsie mount OSNAME.img' is run

  fleetsiemod install [OSTYPE]

- uses instructions customized for 'OSTYPE' to install 'fleetsie' in the overlain OS image.
- 'OSTYPE' defaults to 'Raspberry Pi OS'; do 'fleetsiemod install --help' to list others.
- after this command, you can make any further customizations to the image by manipulating files
in the 'part_N' directories
- do 'fleetsiemod save' to create a new installable image that includes 'fleetsie' and your changes

  fleetsiemod save [NEW_IMAGE_NAME]

- writes the filesystem with your changes to a new, xz-compressed image
- if 'NEW_IMAGE_NAME' is omitted, it defaults to 'OSNAME_fleetsie.img',
- normally, you would only do 'fleetsiemod save' after doing 'fleetsiemod install'
and, optionally, making further changes to the 'part_N' directories

  fleetsiemod updatesd DEVPART1 DEVPART2 ...

- updates the filesystem partitions on an attached SD card from the current image
- 'DEVPART1' is updated from the partition 1 (at 'merged/part_1')
- 'DEVPART2' is updated from the partition 2 (at 'merged/part_2')
- and so on...
- don't include the "/dev/" in DEVPARTN
- example:  fleetsiemod updatesd sdc1 sdc2

This can be useful for testing the provisioning code, by avoiding having to completely rewrite
the SD card each time.

EOF
    exit 1
}

# make_part_names defines symbols for
# partitions/dirs used in unionfs.
# it is passed an integer 1...9 as $1
function make_part_names () {
    orig_main=original
    merged_main=merged
    upper_main=my_work
    orig=${orig_main}/part_$1
    merged=${merged_main}/part_$1
    upper=${upper_main}/part_$1
}

# get_num_parts sets np to the number of partitions
# in the image passed as $1
function get_num_parts () {
    np=`sudo kpartx -l $1 | wc -l`
}

function init_image () {
    if [[ ! "$1" =~ .img.xz$ ]]; then
	echo "this doesn't look like an xz-compressed image file: $1"
	exit 1
    fi
    image=`basename "$1"`
    image=./${image%.xz}
    echo Decompressing to "./$image"
    xz -v --decompress --stdout "$1" > "$image"
    ln -s "$image" .image
    make_part_names 1
    if [[ ! -d $upper_main ]]; then
	git init $upper_main
	printf "This directory holds overlain changes to partitions from `basename \"$image\"`\n" > $upper_main/README.md
	printf "Created new git repo for your changes work in %s\n" $upper_main
    fi
    mount_image
}

function get_image_name () {
    if [[ -L .image ]]; then
	image=`readlink .image`
	image_root=${image%.img}
	return
    fi
    printf "Error: you need to use fleetsiemod init ... to start working on an image\n"
    exit 1
}

function mount_image () {
    check_unmounted
    get_image_name
    echo Mounting partitions in "$image"
    i=1
    for x in `sudo kpartx -av "$image" | awk '{print $3}'`; do
	make_part_names $i
	mkdir -p $orig $merged $upper
	sudo mount -o ro /dev/mapper/$x $orig
	pname=`sudo blkid -s LABEL -o value  /dev/mapper/$x`
	sudo unionfs -o cow -o hide_meta_files $upper=RW:$orig=RO $merged
	rm -f $pname
	ln -s $merged $pname
	echo -n "$pname: " && grep $merged /etc/mtab
	i=$(( $i + 1 ))
    done
    # flag that image is mouned
    touch .mounted
}

function save_image () {
    check_mounted
    get_image_name
    new_name="$1"
    new_image="${1%.xz}"
    # create a file of zeros with the same size as the original image
    rm -f "$new_image"
    size=`stat -Lc %s .image`
    printf "Creating zeroed image of size %s bytes\n" $size
    dd if=/dev/zero of="$new_image" bs=1M count=$(( $size / (1024 * 1024) ))
    set -euo pipefail

    # clone the partition table and filesystems from original image
    # to new one
    SRC_IMG="$image"
    DST_IMG="$new_image"

    # 1. Associate loop devices (with partition scanning)
    LOOP_SRC=$(losetup --show -fP "${SRC_IMG}")
    LOOP_DST=$(losetup --show -fP "${DST_IMG}")

    # 2. Clone partition table
    printf "Cloning partition table from $LOOP_SRC to $LOOP_DST\n"
    sfdisk -d "${LOOP_SRC}" | sfdisk "${LOOP_DST}"

    # 3. Re-scan partitions on the target loop device
    printf "Rescanning partition table on $LOOP_DST\n"
    partprobe "${LOOP_DST}"

    # 4. For each new partition on the target, detect its type and mkfs,
    #    and mount on .new_image/part_pN
    mkdir -p .new_image
    i=1
    for SRCPART in $(ls "${LOOP_SRC}"p*); do
	TYPE=$(blkid -s TYPE -o value "${SRCPART}" || true)
	PART=${SRCPART/$LOOP_SRC/$LOOP_DST}
	case "${TYPE}" in
	    ext2|ext3|ext4)
		mkfs."${TYPE}" -F "${PART}"
		;;
	    xfs)
		mkfs.xfs -f "${PART}"
		;;
	    vfat)
		mkfs.vfat "${PART}"
		;;
	    ntfs)
		mkfs.ntfs -F "${PART}"
		;;
	    swap)
		mkswap "${PART}"
		;;
	    *)
		echo "Warning: unsupported or unknown type '${TYPE}' on ${PART}, skipping"
		continue
		;;
	esac
	mkdir -p .new_image/part_$i
	sudo mount ${PART} .new_image/part_$i
	make_part_names $i
	printf "Doing rsync -a from $merged to .new_image/part_$i\n"
	sudo rsync -a "$merged/" .new_image/part_$i/ || true
	sudo umount ${PART}
	i=$(( $i + 1 ))
    done

    # 5. Detach loop devices
    losetup -d "${LOOP_SRC}"
    losetup -d "${LOOP_DST}"

    printf "Compressing to ${new_image}.xz\n"
    xz -v "${new_image}"
}

function check_mounted() {
    if [[ ! -f .mounted ]]; then
	printf "error: image is not mounted\n"
	exit 1
    fi
}

function check_unmounted() {
    if [[ -f .mounted ]]; then
	printf "error: image is already mounted\n"
	exit 1
    fi
}

function unmount_image () {
    check_mounted
    get_image_name
    get_num_parts $image
    for i in `seq 1 $np`; do
	make_part_names $i
	sudo umount $merged
	sudo umount $orig
    done
    sudo kpartx -dv $image
    rm .mounted
}

function update_sd () {
    check_mounted
    get_image_name
    get_num_parts $image
    for i in `seq 1 $np`; do
	p=${!i}
	if [[ $p == "" ]]; then
	    printf "not enough device partitions given:  missing #%d\n" $i
	    exit 1
	fi
	mp=`findmnt -no TARGET /dev/$p`
	make_part_names $i
	printf "doing rsync -a $merged/ $mp/\n"
	if ! sudo rsync -a $merged/ $mp/; then
	    break
	fi
	printf "rsync successful; unmounting %s\n" $mp
	sudo umount $mp
    done
}

# install_image installs the fleetsie components for the OS given in $1
# onto the currently mounted partitions.
function install_image () {
    check_mounted
    make_part_names
    if [[ ! -d "$FLEETSIE_DIR/os/$1"  ]]; then
	install_usage
    fi
    export TARGET_ROOT="$PWD"
    cd "$FLEETSIE_DIR/os/$1/"
    ./install || exit 1
}

# install usage lists the available options for 'install'
function install_usage () {
    cat <<EOF
Usage: fleetsiemod install OS\n

where OS is one of:
EOF
    for x in "`ls -1 $FLEETSIE_DIR/os`"; do
	printf "\"%s\"\n" "$x"
    done
    exit 1
}

export FLEETSIE_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"
verb=$1
shift
case $verb in
    init)
	if [[ "$1" == "" ]]; then
	    usage
	fi
	init_image "$*"
	;;
    mount)
	mount_image "$*"
	;;
    unmount)
	unmount_image "$*"
	;;
    install)
	if [[ "$1" =~ ^-*h(elp)? ]]; then
	    install_usage
	fi
	os="${1:-Raspberry Pi OS}"
	shift
	install_image "$os" "$*"
	;;
    save)
	if [[ "$1" == "" ]]; then
	    get_image_name
	    iname="${image_root}_fleetsie.img.xz"
	else
	    iname="$1"
	fi
	shift
	save_image "$iname" "$*"
	;;
    updatesd)
	for dp in $*; do
	    if [[ "$dp" == "" ]]; then
		usage
	    fi
	    if ! grep -E " ${dp}\$" /proc/partitions >/dev/null; then
		printf "error: /dev/$dp is really not a disk partition\n"
		echo doing exit 2 now
		exit 2
	    fi
	done
	update_sd $*
	;;
    *) usage
       ;;
esac
