#!/bin/bash

# fleetsieauth - provide credentials to a client device upon receipt
# of a valid one-time-password
#
# This script is (forced to) run on the fleet server when a device
# ssh's in using the fleet credentials which are supplied on the fleetsie
# provisioning USB disk.  It runs as user fleetsie_FLEETNAME.
#
# It reads two items from stdin, supplied by the provisioning device, one per line:
# HWID (as a colon-separated hex string)
# OTP (a 128-char hex string)
#
# There are several possible outcomes:
#
# If the OTP is valid and the corresponding device record has not been claimed
# (i.e. HWID in that DB record is NULL), then fill-in the HWID and other fields
# for the device record, print the "Ok" message and then credentials.

# If the OTP is valid but has been claimed, print the "Try" message and the first
# index of an unclaimed device for the fleet, if there is one.  If not, print the "Full"
# message.
#
# For an invalid OTP or any other case, print the "Error" message and possibly details.

LOG_FILE=~/fleetsie_auth.log
# respond returns a response to the ssh client, copies it to the log, and exits
function response() {
    printf "$*" | tee -a $LOG_FILE
    exit
}

# die returns an error to the ssh client, and exits
function die() {
    response "Error\n$*\n"
}

function suggest_trying() {
    response "Try\n$1\n"
}

function report_full() {
    response "Full\n"
}

function report_bad() {
    response "Bad\n"
}

# log writes info to the log file
function log() {
    printf "%s\n" "$*" >> $LOG_FILE
}

# sanitize removes any characters outside of [_:] and [:alnum:] from the named env var
function sanitize() {
    declare -n v=$1
    v=${v//[^[:alnum:]:_]/}
}

# sanitize_key removes any characters outside of [:alnum:] [:space:] and [-@_=:+/] from the named env var
function sanitize_key() {
    declare -n v=$1
    v=${v//[^-@_=:+\/[:space:][:alnum:]]/}
}

# The fleet name is provided in  environment variable FLEET by the ssh key in /home/fleetsie_fleet/.ssh/authorized_keys

# location of fleet DB; this is generated in advance by fleetsie_gen_srv
DB=~fleetsie/fleets/${FLEET}/fleet.sqlite

# location of provisioning DB; this keeps the reduced version of the DB
# with records of unregistered devices, and with only the id_in_fleet and otp columns
PDB=~fleetsie/fleets/${FLEET}/provisioning.sqlite

# run sqlite in a coprocess; return values left justified in 1 column
coproc SQL { sqlite3 -column $DB 2>&1; }
FROMSQL=${SQL[0]}
TOSQL=${SQL[1]}
sleep 0.1
printf ".prompt \"\" \"\"\n" >&$TOSQL
printf ".timeout 3000\n" >&$TOSQL
read -t 3 ignore <&$FROMSQL
read -t 3 ignore <&$FROMSQL

# sqlite_do runs a command in the attached sqlite database
sqlite_do() {
    log "Doing: $*\n"
    printf "%s;\n" "$*" >&$TOSQL
}

# sqlite_get runs a command in the attached sqlite database
# and returns the result in the variable named in $1
sqlite_get() {
    declare -n v=$1
    shift
    log "Doing: $*\n"
    printf "%s;\n" "$*" >&$TOSQL
    read -t 3 v <&$FROMSQL
    log "Got: $v"
}

log "`date -Isecond`"
read HWID
sanitize HWID
log "Got HWID=$HWID"
if [[ ! $HWID =~ ^([[:xdigit:]]{2}:){5}[[:xdigit:]]{2}$ ]]; then
    # doesn't look like the typical MAC address
    die "invalid hardware ID"
fi

read OTP
sanitize OTP
log "Got OTP=$OTP"

# check whether this is a valid OTP; early, so that we don't
# leak information to a totally unauthorized user.
sqlite_get resp "select count(*) from devices where otp='$OTP'"
if [[ "$resp" -eq 0 ]]; then
    report_bad
fi

# check whether this hwid already registered
sqlite_get resp "select count(*) from devices where hwid='$HWID'"
if [[ "$resp" -ne 0 ]]; then
    die "hardware id $HWID already registered"
fi

# find the OTP in the table, but only if it is not yet registered
# Note that sqlite locks the table before doing the where clause,
# so this is atomic and at most one process can succeed in claiming the
# device record with the matching OTP.
CLIENT_IP=${SSH_CLIENT/ */}
sqlite_do "update devices set hwid='"$HWID"', ts_registered=strftime('%s',datetime()), ip_provisioned_from='"$CLIENT_IP"' where otp='"$OTP"' and hwid is null;"

# did we succeed in registering the device with this OTP?
sqlite_get resp "select hwid from devices where otp='"$OTP"'"
if [[ "$resp" != "$HWID" ]]; then
    # someone else got to the device first, do a query to suggest the index of the OTP to try next
    sqlite_get resp "select min(id_in_fleet) from devices where hwid is null"
    if [[ "$resp" != "" ]]; then
	suggest_trying $resp
    else
	report_full
    fi
fi

# registration successful - drop record from provisioning DB and return details to user
sqlite_do "attach database '$PDB' as db1; delete from db1.devices where otp='$OTP'"
sqlite_get user_pwd "select user_pwd from devices where hwid='$HWID'"
sqlite_get root_pwd "select root_pwd from devices where hwid='$HWID'"
sqlite_get hostname "select hostname from devices where hwid='$HWID'"
sqlite_get fleetuser "select fleetuser from devices where hwid='$HWID'"
sqlite_get tunnel_port "select tunnel_port from devices where hwid='$HWID'"
sqlite_get srv_public_key "select server_public_key from devices where hwid='$HWID'"
sqlite_get srv_private_key "select replace(server_private_key,char(10),',')||',' from devices where hwid='$HWID'"
sqlite_get dev_auth_key "select device_public_key from devices where hwid='$HWID'"
sqlite_get zabbix_psk "select zabbix_psk from zabbix_fleet_psk where fleet='$FLEET'"

printf "Ok\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n" "$user_pwd" "$root_pwd" "$hostname" "$fleetuser" "$tunnel_port" "$srv_public_key" "$srv_private_key" "$dev_auth_key" "$zabbix_psk"
