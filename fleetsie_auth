#!/bin/bash

# fleetsieauth - provide credentials to a client device upon receipt
# of a valid one-time-password
#
# This script is (forced to) run on the fleet server when a device
# ssh's in using the fleet credentials which are supplied on the fleetsie
# provisioning USB disk.  It runs as user fleetsie_FLEETNAME.
#
# It reads two items from stdin, supplied by the provisioning device, one per line:
# HWID (as a colon-separated hex string)
# OTP (a 128-char hex string)
#
# There are several possible outcomes:
#
# If the OTP is valid and the corresponding device record has not been claimed
# (i.e. HWID in that DB record is NULL), then fill-in the HWID and other fields
# for the device record, print the "Ok" message and then credentials.

# If the OTP is valid but has been claimed, print the "Try" message and the first
# index of an unclaimed device for the fleet, if there is one.  If not, print the "Full"
# message.
#
# For an invalid OTP or any other case, print the "Error" message and possibly details.

LOG_FILE=~/fleetsie_auth.log
# respond returns a response to the ssh client, copies it to the log, and exits
function response() {
    printf "$*" | tee -a $LOG_FILE
    exit
}

# die returns an error to the ssh client, and exits
function die() {
    response "Error\n$*\n"
}

function suggest_trying() {
    response "Try\n$1\n"
}

function report_full() {
    response "Full\n"
}

function report_bad() {
    response "Bad\n"
}

# log writes info to the log file
function log() {
    echo "$*" >> $LOG_FILE
}

# sanitize removes any characters outside of [_:] and [:alnum:] from the named env var
function sanitize() {
    declare -n v=$1
    v=${v//[^[:alnum:]:_]/}
}

# sanitize_key removes any characters outside of [:alnum:] [:space:] and [-@_=:+/] from the named env var
function sanitize_key() {
    declare -n v=$1
    v=${v//[^-@_=:+\/[:space:][:alnum:]]/}
}

# The fleet name is provided in  environment variable FLEET by the ssh key in /home/fleetsie_fleet/.ssh/authorized_keys

# location of fleet DB; this is generated in advance by fleetsie_gen_srv
DB=~fleetsie/fleets/${FLEET}/fleet.sqlite

# location of provisioning DB; this keeps the reduced version of the DB
# with records of unregistered devices, and with only the id_in_fleet and otp columns
PDB=~fleetsie/fleets/${FLEET}/provisioning.sqlite

# sqlite runs a set of queries through the devices sqlite database.
# The output is saved in the variable whose name is provided as $1;
# remaining parameters are the db queries.  We use pragma busy_timeout
# to allow for retries of a locked database, and this prints the
# timeout value, so we skip that by piping to tail.
function sqlite() {
    declare -n v=$1
    shift
    v=`sqlite3 $DB "pragma busy_timeout=3000;$*" | tail +2l`
}

read HWID
sanitize HWID
log "Got HWID=$HWID"
if [[ ! $HWID =~ ^([[:xdigit:]]{2}:){5}[[:xdigit:]]{2}$ ]]; then
    # doesn't look like the typical MAC address
    die "invalid hardware ID"
fi

read OTP
sanitize OTP
log "Got OTP=$OTP"

# check whether this is a valid OTP; early, so that we don't
# leak information to a totally unauthorized user.
sqlite resp "select count(*) from devices where otp='$OTP'"
if [[ "$resp" -eq 0 ]]; then
    report_bad
fi

# check whether this hwid already registered
sqlite resp "select count(*) from devices where hwid='$HWID'"
if [[ "$resp" -ne 0 ]]; then
    die "hardware id $HWID already registered"
fi

# find the OTP in the table, but only if it is not yet registered
# Note that sqlite locks the table before doing the where clause,
# so this is atomic and at most one process can succeed in claiming the
# device record with the matching OTP.
CLIENT_IP=${SSH_CLIENT/ */}
sqlite resp "update devices set hwid='"$HWID"', ts_registered=strftime('%s',datetime()), ip_provisioned_from='"$CLIENT_IP"' where otp='"$OTP"' and hwid is null;"

# did we succeed in registering the device with this OTP?
sqlite resp "select hwid from devices where otp='"$OTP"'"
if [[ "$resp" != "$HWID" ]]; then
    # someone else got to the device first, do a query to suggest the index of the OTP to try next
    sqlite resp "select min(id_in_fleet) from devices where hwid is null"
    if [[ "$resp" != "" ]]; then
	suggest_trying $resp
    else
	report_full
    fi
fi

# registration successful - drop record from provisioning DB and return details to user
sqlite _ignore_ "attach database '$PDB' as db1; delete from db1.devices where otp='$OTP'"
sqlite user_pwd "select user_pwd from devices where hwid='$HWID'"
sqlite root_pwd "select root_pwd from devices where hwid='$HWID'"
sqlite hostname "select hostname from devices where hwid='$HWID'"
sqlite fleetuser "select fleetuser from devices where hwid='$HWID'"
sqlite tunnel_port "select tunnel_port from devices where hwid='$HWID'"
sqlite srv_public_key "select server_public_key from devices where hwid='$HWID'"
sqlite srv_private_key "select server_private_key from devices where hwid='$HWID'"
sqlite dev_auth_key "select device_public_key from devices where hwid='$HWID'"
sqlite zabbix_psk "select zabbix_psk from zabbix_fleet_psk where fleet='$FLEET'"

# replace EOL with , in private key file
srv_private_key_compact=`echo "$srv_private_key" | tr '\n' ','`
printf "Ok\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n" "$user_pwd" "$root_pwd" "$hostname" "$fleetuser" "$tunnel_port" "$srv_public_key" "$srv_private_key_compact" "$dev_auth_key" "$zabbix_psk"
