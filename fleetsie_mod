#!/bin/bash

# fleetsiemod - manage the creation of a modified OS image to be used for the fleet

function usage () {
    # usage below is copied from the `fleetsiemod` section of README.md
    cat <<EOF

### Commands:

  fleetsie_mod init PATH/OSNAME.img.xz

- decompresses the image using xz and writes it to file OSNAME.img in the current directory
- mounts all partitions in the image, as is done by the 'fleetsie_mod mount' command below
- creates a symlink from '.image -> OSNAME.img'
- initializes a git repo in 'my_work', where overlays for each of the partitions in 'OSNAME.img'
will be created, so that you can use version control to track your work.

  fleetsie_mod mount

- mounts each partition in 'OSNAME.img' read-only to directory 'original/part_N'
- creates an overlay mount for each partition; the merged mount is in 'part_N', where N is 1, 2, ...
- changes to the underlying image will be reflected in directories '.new_N'; these are created
if they do not already exist.
- symlinks are created from the underlying partition labels to part_N; e.g. 'bootfs -> part_1'

  fleetsie_mod unmount

- unmounts the merged and original filesystems
- changes made remain available in the '.new_N' directories and will be
automatically restored the next time 'fleetsie_mount OSNAME.img' is run

  fleetsie_mod install [OSTYPE]

- uses instructions customized for 'OSTYPE' to install 'fleetsie' in the overlain OS image.\
- 'OSTYPE' defaults to 'Raspberry Pi OS'; do 'fleetsie_mod install --help' to list others.
- after this command, you can make any further customizations to the image by manipulating files
in the 'my_work/part_N' directories
- in particular, these files are treated specially:
  - my_work/part_2/opt/fleetsie/custom_pre is a folder which gets copied onto the SD card
    so that the running system will see it in '/opt/fleetsie/custom_pre'
    The fleetsie_provision script uses it early in the provisioning process, before
    even trying to find the USB provisioning disk.
  - my_work/part_2/opt/fleetsie/custom_pre/setup - if this exists, it is a script which will be run
    early by the fleetsie_provision script
  - my_work/part_2/opt/fleetsie/custom_pre/packages - if this folder exists, any .deb packages it holds
    will be installed early by the fleetsie_provision script (after 'setup' is run, but before 'overlay'
    is extracted)
  - my_work/part_2/opt/fleetsie/custom_pre/overlay.tar.xz - if this exists, it is an archive which will
    be extracted to "/" as user root early by the fleetsie_provision script, right after running the
    setup script mentioned previously
  - my_work/part_2/opt/fleetsie/custom_pre/cleanup - if this exists, it is a script which will be run
    early by the fleetsie_provision script, right after extracting the overlay image just mentioned

  - my_work/part_2/opt/fleetsie/custom_pre/pronunciation.txt - if
    this exists, it is used to help the text-to-speech system
    pronounce words or phrases associated with your project, by
    providing phonetically-spelled replacements. The file is treated
    as consecutive pairs of lines, with the first line in the pair
    giving a 'from' expression, and the second line, a 'to'
    expression. These pairs will be applied by bash in order when
    modifying a string 's' before speaking it.  Specifically, each
    pair causes bash to do 's="${s//$from/$to}"'.  For example,
    the two lines:

        sqlite
        ess-cue-light

    cause the TTS system to pronounce 'sqlite' as 'ess-cue-light'.

- do 'fleetsie_mod save' to create a new installable image that includes 'fleetsie' and your changes

  fleetsie_mod save [NEW_IMAGE_NAME]

- writes the filesystem with your changes to a new, xz-compressed image
- if 'NEW_IMAGE_NAME' is omitted, it defaults to 'OSNAME_fleetsie.img',
- normally, you would only do 'fleetsie_mod save' after doing 'fleetsie_mod install'
and, optionally, making further changes to the 'part_N' directories

  fleetsie_mod updatesd DEVPART1 DEVPART2 ...

- updates the filesystem partitions on an attached SD card from the current image
- 'DEVPART1' is updated from the partition 1 (at 'merged/part_1')
- 'DEVPART2' is updated from the partition 2 (at 'merged/part_2')
- and so on...
- don't include the "/dev/" in DEVPARTN
- example:  fleetsie_mod updatesd sdc1 sdc2

This can be useful for testing the provisioning code, by avoiding having to completely rewrite the SD card each time.

EOF
    exit 1
}

# make_part_names defines symbols for
# partitions/dirs used in unionfs.
# it is passed an integer 1...9 as $1
function make_part_names () {
    orig_main=original
    merged_main=merged
    upper_main=my_work
    orig=${orig_main}/part_$1
    merged=${merged_main}/part_$1
    upper=${upper_main}/part_$1
}

# get_num_parts sets np to the number of partitions
# in the image passed as $1
function get_num_parts () {
    np=`sudo kpartx -l $1 | wc -l`
}

function init_image () {
    if [[ ! "$1" =~ .img.xz$ ]]; then
	echo "this doesn't look like an xz-compressed image file: $1"
	exit 1
    fi
    image=`basename "$1"`
    image=./${image%.xz}
    echo Decompressing to "./$image"
    xz -v --decompress --stdout "$1" > "$image"
    ln -s "$image" .image
    make_part_names 1
    if [[ ! -d $upper_main ]]; then
	git init $upper_main
	printf "This directory holds overlain changes to partitions from `basename \"$image\"`\n" > $upper_main/README.md
	printf "Created new git repo for your changes work in %s\n" $upper_main
    fi
    mount_image
}

function get_image_name () {
    if [[ -L .image ]]; then
	image=`readlink .image`
	image_root=${image%.img}
	return
    fi
    printf "Error: you need to use fleetsiemod init ... to start working on an image\n"
    exit 1
}

function mount_image () {
    check_unmounted
    get_image_name
    echo Mounting partitions in "$image"
    i=1
    for x in `sudo kpartx -av "$image" | awk '{print $3}'`; do
	make_part_names $i
	mkdir -p $orig $merged $upper
	sudo mount -o ro /dev/mapper/$x $orig
	pname=`sudo blkid -s LABEL -o value  /dev/mapper/$x`
	sudo unionfs -o cow -o allow_other -o hide_meta_files $upper=RW:$orig=RO $merged
	sudo rm -f $pname
	sudo ln -s $merged $pname
	echo -n "$pname: " && grep $merged /etc/mtab
	i=$(( $i + 1 ))
    done
    # flag that image is mounted
    touch .mounted
}

function save_image () {
    check_mounted
    get_image_name
    new_name="$1"
    new_image="${1%.xz}"
    # create a file of zeros with the same size as the original image
    rm -f "$new_image"
    size=`stat -Lc %s .image`
    printf "Creating zeroed image of size %s bytes\n" $size
    dd if=/dev/zero of="$new_image" bs=1M count=$(( $size / (1024 * 1024) ))
    set -euo pipefail

    # clone the partition table and filesystems from original image
    # to new one
    SRC_IMG="$image"
    DST_IMG="$new_image"

    # 1. Associate loop devices (with partition scanning)
    LOOP_SRC=$(sudo losetup --show -fP "${SRC_IMG}")
    LOOP_DST=$(sudo losetup --show -fP "${DST_IMG}")

    # 2. Clone partition table
    printf "Cloning partition table from $LOOP_SRC to $LOOP_DST\n"
    # This works, except it generates new Partition UUIDs, which have to be corrected later in cmdline.txt and fstab
    #    sfdisk -d "${LOOP_SRC}" | sfdisk "${LOOP_DST}"
    # So instead, we just assume it's a 512-byte MBR and copy it directly
    sudo dd if=$LOOP_SRC of=$LOOP_DST bs=512 count=1

    # 3. Re-scan partitions on the target loop device
    printf "Rescanning partition table on $LOOP_DST\n"
    sudo partprobe "${LOOP_DST}"

    # 4. For each new partition on the target, detect its type and mkfs,
    #    and mount on .new_image/part_pN
    mkdir -p .new_image
    i=1
    for SRCPART in $(ls "${LOOP_SRC}"p*); do
	TYPE=$(sudo blkid -s TYPE -o value "${SRCPART}" || true)
	PART=${SRCPART/$LOOP_SRC/$LOOP_DST}
	case "${TYPE}" in
	    ext2|ext3|ext4)
		sudo mkfs."${TYPE}" -F "${PART}"
		;;
	    xfs)
		sudo mkfs.xfs -f "${PART}"
		;;
	    vfat)
		sudo mkfs.vfat "${PART}"
		;;
	    ntfs)
		sudo mkfs.ntfs -F "${PART}"
		;;
	    swap)
		sudo mkswap "${PART}"
		;;
	    *)
		echo "Warning: unsupported or unknown type '${TYPE}' on ${PART}, skipping"
		continue
		;;
	esac
	sudo mkdir -p .new_image/part_$i
	sudo mount ${PART} .new_image/part_$i
	make_part_names $i
	safe_rsync "$merged/" .new_image/part_$i/ -a || true
	sudo umount ${PART}
	i=$(( $i + 1 ))
    done

    # 5. Detach loop devices
    sudo losetup -d "${LOOP_SRC}"
    sudo losetup -d "${LOOP_DST}"

    rm -f "${new_image}.xz"
    printf "Compressing to ${new_image}.xz\n"
    xz -v "${new_image}"
}

function check_mounted() {
    if [[ ! -f .mounted ]]; then
	printf "error: image is not mounted\n"
	exit 1
    fi
}

function check_unmounted() {
    if [[ -f .mounted ]]; then
	printf "error: image is already mounted\n"
	exit 1
    fi
}

function unmount_image () {
    check_mounted
    get_image_name
    get_num_parts $image
    for i in `seq 1 $np`; do
	make_part_names $i
	sudo umount $merged
	sudo umount $orig
    done
    sudo kpartx -dv $image
    rm .mounted
}

function update_sd () {
    check_mounted
    get_image_name
    get_num_parts $image
    for i in `seq 1 $np`; do
	p=${!i}
	if [[ $p == "" ]]; then
	    printf "not enough device partitions given:  missing #%d\n" $i
	    exit 1
	fi
	mp=`findmnt -no TARGET /dev/$p`
	if [[ "$mp" == "" ]]; then
	    mp=`mktemp -d`
	    if ! sudo mount /dev/$p $mp; then
		printf "warning: unable to mount /dev/$p; aborting update_sd\n"
		exit 2
	    fi
	    printf "mounted /dev/$p on $mp"
	fi
	make_part_names $i
	safe_rsync $merged/ $mp/ -a || true
	printf "rsync done - check for errors, though; unmounting %s\n" $mp
	sudo umount $mp
    done
}

# install_image installs the fleetsie components for the OS given in $1
# onto the currently mounted partitions.
function install_image () {
    check_mounted
    make_part_names
    if [[ ! -d "$FLEETSIE_DIR/os/$1"  ]]; then
	install_usage
    fi
    export TARGET_ROOT="$PWD"
    cd "$FLEETSIE_DIR/os/$1/"
    . ./install || exit 1
}

# safe_rsync rsyncs $1 to $2 with options in $3, $4, ...
# but prompts the user and makes sure that $2 is either in /media
# or below the CWD.
function safe_rsync () {
    SRC="$1"
    DST="$2"
    shift 2
    OPTS="$*"
    OK=""
    if [[ `cd $DST && pwd` =~ ^$PWD || $DST =~ ^/media ]]; then
	# destination folder is below current directory or somewhere mounted in /media
	OK=1
    fi
    if [[ ! $OK ]]; then
	printf "error: refusing to do dangerous rsync with target=$DST\n"
	exit 2
    fi
    printf "Are you sure you want to do rsync $OPTS $SRC $DST\n(y/N)? "
    read x
    RESP=${x:0:1}
    if [[ $RESP != "y" && $RESP != "Y" ]]; then
	printf 'rsync cancelled!  not doing rest of command\n'
	exit 3
    fi
    sudo rsync $OPTS "$SRC" "$DST"
}



# install usage lists the available options for 'install'
function install_usage () {
    cat <<EOF
Usage: fleetsiemod install OS\n

where OS is one of:
EOF
    for x in "`ls -1 $FLEETSIE_DIR/os`"; do
	printf "\"%s\"\n" "$x"
    done
    exit 1
}

export FLEETSIE_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"
verb=$1
shift
case $verb in
    init)
	if [[ "$1" == "" ]]; then
	    usage
	fi
	init_image "$*"
	;;
    mount)
	mount_image "$*"
	;;
    unmount)
	unmount_image "$*"
	;;
    install)
	if [[ "$1" =~ ^-*h(elp)? ]]; then
	    install_usage
	fi
	os="${1:-Raspberry Pi OS}"
	shift
	install_image "$os" "$*"
	;;
    save)
	if [[ "$1" == "" ]]; then
	    get_image_name
	    iname="${image_root}_fleetsie.img.xz"
	else
	    iname="$1"
	fi
	shift
	save_image "$iname" "$*"
	;;
    updatesd)
	for dp in $*; do
	    if [[ "$dp" == "" ]]; then
		usage
	    fi
	    if ! grep -E " ${dp}\$" /proc/partitions >/dev/null; then
		printf "error: /dev/$dp is really not a disk partition\n"
		echo doing exit 2 now
		exit 2
	    fi
	done
	update_sd $*
	;;
    *) usage
       ;;
esac
