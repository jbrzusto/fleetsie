#!/bin/bash

# fleetsie_provision: provision this device using files on an attached USB drive

# This script is run from a fleetsie-modified OS image on the Pi during
# the second boot session (i.e. after the first session, which resizes the
# partition etc.)

# Progress is logged:
# - initially, to /home/pi/fleetsie_provision.log
# - once the provisioning USB disk is detected, to USB:/fleetsie/fleetsie_provision.log

# initial provisioning log is in home folder on sd card, since
# no USB drive found yet
LOGFILE="/home/$USER1000/fleetsie_provisioning_log.txt"

# fatal is called for a fatal error.  It writes any supplied arguments
# to $LOGFILE if defined, and then just slowly flash the red LED
function fatal() {
    if [[ "$LOGFILE" ]]; then
	echo "$*" >> $LOGFILE
	printf "Provisioning ended at `date`\n\n" >> $LOGFILE
	say "$* . Provisioning ended at `date`"
	sync
    fi
    while true; do
	set_leds_for 1 0 1
	set_leds_for 0 0 1
    done
}

# on a warning, write any supplied arguments to $LOGFILE, if defined
function warning() {
    if [[ "$LOGFILE" ]]; then
	echo "warning: $*" >> $LOGFILE
	say "warning. $*"
	sync
    fi
}

# write any supplied arguments to $LOGFILE, if defined
function info() {
    if [[ "$LOGFILE" ]]; then
	echo "`date`: $*" >> $LOGFILE
	sync
	say "$*"
    fi
}

# make any line-endings in file $1 just be a single '\n', no '\r'
# as a side effect, clobbers blank lines, which is fine for our purposes.
function fix_line_endings () {
    if [[ -f "$1" ]]; then
	local tmp="`mktemp`"
	cat "$1" | tr -s '\r' '\n' > "$tmp"
	cat "$tmp" > "$1"
	rm "$tmp"
    fi
}

# fix file permissions and ownership on the ~/.ssh for the user passed as $1
function fixup_ssh_perms () {
    if [[ "$1" == "root" ]]; then
	DIR=/root/.ssh
    else
	DIR=/home/$1/.ssh
    fi
    # ensure file ownership is correct
    chown -R $1:$1 $DIR
    # ensure directory permissions are u=rwx, og=rx
    chmod u=rwx,og=rx $DIR
    # ensure authorized_keys permission is u=rw, og=r
    chmod u=rw,og=r $DIR/authorized_keys || true
    # ensure known_hosts permission is u=rw, og=r
    chmod u=rw,og=r $DIR/authorized_keys || true
    # ensure config permission is u=rw, og=r
    chmod u=rw,og=r $DIR/config || true
    # ensure public keys are u=rw,og=r and private keys are u=rw,og=
    pushd $DIR
    for pk in *.pub; do
	chmod u=rw,og=r $pk
	chmod u=rw,og= ${pk%.pub}
    done
    popd
}

# use the RPi LEDS (red, green)
RED_LED=/sys/class/leds/PWR/brightness
RED_CTRL=/sys/class/leds/PWR/trigger
GRN_LED=/sys/class/leds/ACT/brightness
GRN_CTRL=/sys/class/leds/ACT/trigger

# init_leds should be called once before calling set_leds_forfor
# It tries to disable other LED uses, and sets up FDs
# for control registers and brightness.
function init_leds() {
    exec {RED_LED_FD}>$RED_LED
    exec {GRN_LED_FD}>$GRN_LED
    exec {RED_LED_CTRL_FD}>$RED_CTRL
    exec {GRN_LED_CTRL_FD}>$GRN_CTRL
    printf "none\n" >&$GRN_LED_CTRL_FD
    printf "none\n" >&$RED_LED_CTRL_FD
}

# set_leds_for R G TIME sets red LED to R (0 or 1),
# green LED to G (0 or 1) and sleeps for TIME
function set_leds_for() {
    printf "$1\n" >&$RED_LED_FD
    printf "$2\n" >&$GRN_LED_FD
    sleep $3
}

# when finished provisioning, blink R+G leds
# in tandem
function done_prov() {
    while true; do
	set_leds_for 1 1 .3
	set_leds_for 0 0 .3
	sleep 1
    done
}

SPOKEN_MESSAGE_FILE=/tmp/spoken_message.wav
SPOKEN_MESSAGE_FILE_TEMP=/tmp/spoken_message_tmp.wav

# init_speech looks for a text-to-speech program,
# and if one exists, start a task that repeatedly plays
# /tmp/spoken_message.wav, sleeping 1 s in between.
# it also sets the SPEECH_COMMAND variable used by say().
function init_speech() {
    # Currently, this only supports pico2wave from package ttspico-utils
    # Hopefully this was installed in the custom_pre stage of provisioning,
    # or was already in the OS image.
    # I find the en-GB voice more clear than the en-US voice.
    if which pico2wave > /dev/null; then
	SPEECH_COMMAND="pico2wave -l en-GB -w $SPOKEN_MESSAGE_FILE_TEMP"
	nohup bash -c "while true; do if [[ -f $SPOKEN_MESSAGE_FILE ]]; then aplay $SPOKEN_MESSAGE_FILE; fi; sleep 1; done" &
    fi
}

# say a phrase through the audio jack, if possible
# if SPEECH_COMMAND is set, that program is used to generate
# SPOKEN_MESSAGE_FILE, which will be spoken through the audio
# jack by the background task launched in init_speech()
function say() {
    if [[ ! "$SPEECH_COMMAND" ]]; then
	return
    fi
    $SPEECH_COMMAND "$*"
    # (atomically) move the synthesized audio file to its destination
    mv -f $SPOKEN_MESSAGE_FILE_TEMP $SPOKEN_MESSAGE_FILE
}

init_leds
init_speech

# get unique HWID for this device
HWID=`cat /sys/class/net/eth0/address`

# do some raspi-config stuff to avoid needing the user to do it
# in rpi-imager

info "enabling ssh service"

# enable ssh - doing this with "raspi-config nonint do_ssh 1" did not work
touch /boot/firmware/ssh
systemctl start sshswitch.service

info "using raspi-config to set the wifi country code to Canada"

# set the wifi country (without this, rfkill blocks use of wifi)
raspi-config nonint do_wifi_country CA

# get name of user with id=1000, typically the first non-privileged user.
USER1000=`id -nu 1000`

# perform any pre-customization from /opt/fleetsie
PRE_CUSTOM_DIR=/opt/fleetsie/custom_pre
if [[ -d $PRE_CUSTOM_DIR ]]; then
    pushd $PRE_CUSTOM_DIR
    info "Starting custom pre-provisioning; any subsequent errors are likely in custom code, and not in fleetsie."
    if [[ -f setup ]]; then
	info "Running customize/setup..."
	if . ./setup 2>/tmp/setuplog.txt; then
	    info "Setup completed successfully."
	else
	    info "error while running setup: `cat /tmp/setuplog.txt`"
	fi
    else
	info "No custom setup script found."
    fi
    if [[ -d packages ]]; then
	pushd packages
	info "Installing custom_pre packages:\n`ls -1`\n"
	if dpkg-deb -i ./*deb 2>/tmp/packagelog.txt; then
	    info "Successful."
	else
	    info "failed to install packages: `cat /tmp/packagelog.txt`"
	fi
	popd
    else
	info "No custom_pre/packages folder found."
    fi
    if [[ -f overlay.tar.xz ]]; then
	info "Extracting overlay.tar.xz to /..."
	if tar -C / -xJvf overlay.tar.xz 2>/tmp/overlaylog.txt; then
	    info "Overlay extraction completed successfully."
	else
	    info "error while extracting overlay: `cat /tmp/overlaylog.txt`"
	fi
    else
	info "No custom overlay.tar.xz archive found."
    fi
    if [[ -f cleanup ]]; then
	info "Running customize/cleanup..."
	if . ./setup 2>/tmp/cleanuplog.txt; then
	    info "Cleanup completed successfully."
	else
	    info "error while running cleanup: `cat /tmp/cleanuplog.txt`"
	fi
    else
	info "No custom cleanup script found."
    fi
    info "Ending custom pre-provisioning."
    popd
else
    info "No $PRE_CUSTOM_DIR found - skipping custom pre-provisioning."
fi

info "waiting for a USB drive to be found or plugged in"
# wait for a USB drive
while true; do
      if grep -E "sda[0-9]?$" /proc/partitions > /dev/null 2>&1; then
      	  break
      fi
      set_leds_for 1 1 0.5
      set_leds_for 0 0 0.5
done

mkdir -p /tmp/usb
mounted=""
tmp=`mktemp -d`
for PART in `grep -E "sda[0-9]$" /proc/partitions | awk '{print $4}'`; do
    mp=`findmnt -no TARGET $PART`
    if [[ "$mp" ]]; then
	 if [[ -d "$mp/fleetsie" ]]; then
	     tmp=mp
	     break
	 fi
	 continue
    fi
    if mount /dev/$PART $tmp; then
	## check for fleetsie directory on this partition
	if [[ -d $tmp/fleetsie ]]; then
	    mounted=1
	    break
	else
	    umount $tmp
	fi
    fi
done
if [[ ! "$mounted" ]]; then
    fatal
fi
info "found fleetsie directory on /dev/$PART"
cd $tmp/fleetsie

# switch logging target; this makes it easier to check
# the log, since it's on the USB drive
LOGFILE="$PWD/fleetsie_provisioning_log.txt"
info "Provisioning started on device $HWID from $PART"

## try provision wifi
if [[ ! -f "wifi.txt" ]]; then
    fatal "can't find fleetsie/wifi.txt on USB disk\nfirst line should be the WiFi network name (ESSID), second line should be the WiFi password"
fi
fix_line_endings "wifi.txt"
con=""
{
    while true; do
	if ! read ESSID; then
	    break
	fi
	if ! read PASSWD; then
	    info "wifi.txt is missing a password line for $ESSID"
	    break
	fi
	info "trying nmcli device wifi con \"$ESSID\" password \"$PASSWD\""
	CMD="nmcli device wifi con \"$ESSID\" password \"$PASSWD\""
	read CONRES < <( bash -c "$CMD" 2>&1)
	if [[ "$CONRES" =~ "successfully activated" ]]; then
            info "Connected WiFi to $ESSID"
	    con=1
	    break
	else
            info "Could not connect WiFi to $ESSID; error was $CONRES"
	fi
    done
 } < wifi.txt

if [[ $con != 1 ]]; then
    fatal "unable to connect to any WiFi networks given in wifi.txt"
fi

info "waiting for system clock to be synchronized to network time"

while true; do
    if [[ -f /var/lib/systemd/timesync/clock ]]; then
	break
    fi
    sleep 1
done

if ! sqlite3 < /dev/null; then
    info "updating apt and installing sqlite3"
    if ! apt update || ! apt install sqlite3 ; then
	fatalf "unable to install sqlite3"
    fi
fi

info "looking for fleet ssh keys in fleet.txt"

## try get ssh keys for fleet server
if [[ ! -f "fleet.txt" ]]; then
    fatal "can't find fleetsie/fleet.txt on USB disk\nfirst line should be fleet server hostname; e.g. whoflewby.org\nsecond line should be fleet name; e.g. ampi\n"
fi
fix_line_endings fleet.txt
{ read FLEETHOST && read FLEETNAME && read FLEETKNOWNHOST; } < fleet.txt
if [[ ! $FLEETHOST ]]; then
	fatal "can't read fleet host name from line 1 of fleetsie/fleet.txt file on USB disk"
fi
if [[ ! $FLEETNAME ]]; then
	fatal "can't read fleet name from line 2 of fleetsie/fleet.txt file on USB disk"
fi

if [[ ! $FLEETKNOWNHOST ]]; then
	fatal "can't read known_hosts line for fleet host from from line 3 of fleetsie/fleet.txt file on USB disk"
fi

DB=provisioning.sqlite
PRIVKEY=id_ed25519_provision_$FLEETNAME
PUBKEY="$PRIVKEY.pub"

if [[ ! -f $PRIVKEY || ! -f $PUBKEY || ! -f $DB ]]; then
    fatal "can't find one or more files needed for connecting to fleet server.\nneed:\n$PRIVKEY\n$PUBKEY\nprovisioning.sqlite\n"
fi

info "Appending known_hosts from USB drive to /root/.ssh/known_hosts"
mkdir -p /root/.ssh
echo "$FLEETKNOWNHOST" >> /root/.ssh/known_hosts
cp  $PRIVKEY $PUBKEY /root/.ssh/
fixup_ssh_perms root

info "sshing to fleet server $FLEETHOST"

REPLY_FILE=/tmp/fleetsieauth.txt
ERROR_FILE=/tmp/fleetsieauth.err

info "Trying to claim an unregistered device:"
while true; do
    OTP=`sqlite3 $DB "select otp from devices order by id_in_fleet limit 1"`
    if [[ "$OTP" == "" ]]; then
	fatal "no devices left in $DB - contact an administrator for more"
    fi
    info " - trying otp=${OTP:0:16}..."
    if !  printf "%s\n%s\n" "$HWID" "$OTP" | \
	    ssh -T -oStrictHostKeyChecking=true -i /root/.ssh/$PRIVKEY fleetsie_$FLEETNAME@$FLEETHOST \
		> $REPLY_FILE 2> $ERROR_FILE; then
	fatal "error trying to ssh to $FLEETHOST: `cat $ERROR_FILE`"
    fi
    {
	read rv
	case $rv in
	    Bad)
		info "server $FLEETHOST reports OTP=$OTP is bad; trying next OTP"
		sqlite3 $DB "delete from devices where otp='$OTP'"
		;;
	    Try)
		read DEVNUM
		# server suggests trying device with id_in_fleet = DEVNUM; delete devices with smaller id_in_fleet
		# because the server is effectively telling us they have been claimed.
		sqlite3 $DB "delete from devices where id_in_fleet < $DEVNUM;"
		info "server $FLEETHOST suggests trying device with id_in_fleet=$DEVNUM"
		;;
	    Error)
		read ERRMSG
		fatal "server $FLEETHOST reported this error: $ERRMSG"
		;;
            Full)
                fatal "server $FLEETHOST reports there are no available devices allocated to the $FLEETNAME fleet.  Contact an administrator to fix this."
                ;;
	    Ok)
		if ! read HOSTNAME || ! read FLEETUSER || ! read PORT || ! read SRVPUBKEY || ! read SRVPRIVKEY || ! read DEVAUTHKEY ; then
		    fatal "server $FLEETHOST gave bad reply: `cat $REPLY_FILE`"
		fi
		info "Successfully claimed!"
		info "Setting hostname to $HOSTNAME"
		echo "$HOSTNAME" /etc/hostname
		info "Saving ssh keys for access to $HOSTNAME and $FLEETHOST"
		mkdir -p /home/${USER1000}/.ssh
		echo "$FLEETKNOWNHOST" >> /home/${USER1000}/.ssh/known_hosts
		ln -s "$PORT" /home/${USER1000}/.ssh/fleetsie_tunnel_port
		echo "$SRVPUBKEY" > /home/${USER1000}/.ssh/fleetsie.pub
		echo "$SRVPRIVKEY" > /home/${USER1000}/.ssh/fleetsie
		echo "$FLEETKNOWNHOST" >> /home/${USER1000}/.known_hosts
		echo "$DEVAUTHKEY" >> /home/{$USER1000}/.ssh/authorized_keys
		info "Configuring ssh for logging into fleetsie = $FLEETUSER@$FLEETHOST"
		cat >> /home/${USER1000}/.ssh/config <<EOF
Host fleetsie
   Hostname $FLEETHOST
   User $FLEETUSER
   StrictHostKeyChecking yes
   IdentityFile ~/.ssh/fleetsie
   IdentitiesOnly yes
EOF
		fixup_ssh_perms $USER1000
		if ! su -c "ssh -i /home/${USER1000}/.ssh/fleetsie fleetsie date" $USER1000 > /dev/null 2>/tmp/ssherror.txt; then
		    fatal "could not login to $FLEETHOST with new credentials: `cat /tmp/ssherror.txt`"
		fi
		info "Removing entry with this OTP from devices table"
		sqlite3 $DB "delete from devices where otp='$OTP'"
		break
                ;;
            *) fatal "server $FLEETHOST replied to device claim request with unknown reponse: $rv"
                ;;
	esac
    } < $REPLY_FILE
done

if [[ -d custom_post ]]; then
    pushd custom_post
    info "Starting custom post-provisioning; any subsequent errors are likely in custom code, and not in fleetsie."
    if [[ -f setup ]]; then
	info "Running customize/setup..."
	if . ./setup 2>/tmp/setuplog.txt; then
	    info "Setup completed successfully."
	else
	    info "error while running setup: `cat /tmp/setuplog.txt`"
	fi
    else
	info "No custom setup script found."
    fi
    if [[ -d packages ]]; then
	pushd packages
	info "Installing custom_post packages:\n`ls -1`\n"
	if dpkg-deb -i ./*deb 2>/tmp/packagelog.txt; then
	    info "Successful."
	else
	    info "failed to install packages: `cat /tmp/packagelog.txt`"
	fi
	popd
    else
	info "No custom_pre/packages folder found."
    fi
    if [[ -f overlay.tar.xz ]]; then
	info "Extracting overlay.tar.xz to /..."
	if tar -C / -xJvf overlay.tar.xz 2>/tmp/overlaylog.txt; then
	    info "Overlay extraction completed successfully."
	else
	    info "error while extracting overlay: `cat /tmp/overlaylog.txt`"
	fi
    else
	info "No custom overlay.tar.xz archive found."
    fi
    if [[ -f cleanup ]]; then
	info "Running customize/cleanup..."
	if . ./setup 2>/tmp/cleanuplog.txt; then
	    info "Cleanup completed successfully."
	else
	    info "error while running cleanup: `cat /tmp/cleanuplog.txt`"
	fi
    else
	info "No custom cleanup script found."
    fi
    info "Ending custom post-provisioning."
    popd
else
    info "No custom_post directory on USB disk."
fi
info "Provisioning ended at `date`."
umount $tmp
# Put the final message on a loop.  The provisioner needs to hear the
# host ID spelled out clearly, so they can write it on a physical
# label.
say "This raspberry pi is now ready to deploy as part of the $FLEET_NAME fleet.  Please label it with this code. `echo $HOSTNAME | sed -E -e 's/(.)/\1, /g;s/-/dash/g'`"
done_prov
