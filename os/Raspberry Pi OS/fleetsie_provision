#!/bin/bash

# fleetsie_provision: provision this device using files on an attached USB drive

# on a fatal error, write any supplied arguments to $LOGFILE if defined,
# and then just flash the red LED
function fatal() {
    if [[ "$LOGFILE" ]]; then
	echo "$*" >> $LOGFILE
	printf "Provisioning ended at `date`\n\n" >> $LOGFILE
	sync
    fi
    echo none > /sys/class/leds/ACT/trigger
    echo none > /sys/class/leds/PWR/trigger
    echo 0 > /sys/class/leds/ACT/brightness
    while true; do
	echo 1 > /sys/class/leds/PWR/brightness
	sleep .2
	echo 0 > /sys/class/leds/PWR/brightness
	sleep .2
    done
}

# on a warning, write any supplied arguments to $LOGFILE, if defined
function warning() {
    if [[ "$LOGFILE" ]]; then
	echo "warning: $*" >> $LOGFILE
	sync
    fi
}

# write any supplied arguments to $LOGFILE, if defined
function info() {
    if [[ "$LOGFILE" ]]; then
	echo "$*" >> $LOGFILE
	sync
    fi
}

# make any line-endings in file $1 just be a single '\n', no '\r'
# as a side effect, clobbers blank lines, which is fine for our purposes.
function fix_line_endings () {
    if [[ -f "$1" ]]; then
	local tmp="`mktemp`"
	cat "$1" | tr -s '\r' '\n' > "$tmp"
	cat "$tmp" > "$1"
	rm "$tmp"
    fi
}

RED_LED=/sys/class/leds/PWR/brightness
RED_CTRL=/sys/class/leds/PWR/trigger
GRN_LED=/sys/class/leds/ACT/brightness
GRN_CTRL=/sys/class/leds/ACT/trigger

function grnctrl() {
    printf "$1\n" > $GRN_CTRL
}

function grnled() {
    printf "$1\n" > $GRN_LED
}

function redled() {
    printf "$1\n" > $RED_LED
}

function redctrl() {
    printf "$1\n" > $RED_CTRL
}

function doneprov() {
    grnctrl none; redctrl none
    while true; do
	redled 1; grnled 1; sleep .2
	redled 0; grnled 0; sleep .2
	redled 1;           sleep .2
	redled 0;           sleep .2
	redled 1;           sleep .2
	redled 0;           sleep .2
    done
}

# get unique HWID for this device
HWID=`cat /sys/class/net/eth0/address`

# do some raspi-config stuff
raspi-config nonint do_ssh 1
raspi-config nonint do_wifi_country CA

# initial provisioning log is in home folder on sd card, since
# no USB drive found yet
LOGFILE="/home/pi/fleetsie_provision.log"

info "waiting for systemctl is-system-running --wait"

# wait for systemctl to have brought up all the usual units
systemctl is-system-running --wait

info "waiting for a USB drive to be found or plugged in"
# wait for a USB drive
while true; do
      if grep -E "sda[0-9]?$" /proc/partitions > /dev/null 2>&1; then
      	  break
      fi
      echo none > /sys/class/leds/ACT/trigger
      echo 1 > /sys/class/leds/ACT/brightness
      echo 1 > /sys/class/leds/PWR/brightness
      sleep 1
      echo 0 > /sys/class/leds/ACT/brightness
      echo 0 > /sys/class/leds/PWR/brightness
      sleep 1
done

mkdir -p /tmp/usb
mounted=""
tmp=`mktemp -d`
for PART in `grep -E "sda[0-9]$" /proc/partitions | awk '{print $4}'`; do
    mp=`findmnt -no TARGET $PART`
    if [[ "$mp" ]]; then
	 if [[ -d "$mp/fleetsie" ]]; then
	     tmp=mp
	     break
	 fi
	 continue
    fi
    if mount /dev/$PART $tmp; then
	## check for fleetsie directory on this partition
	if [[ -d $tmp/fleetsie ]]; then
	    mounted=1
	    break
	else
	    umount $tmp
	fi
    fi
done
if [[ ! "$mounted" ]]; then
    fatal
fi
info "found fleetsie directory on /dev/$PART"

cd $tmp/fleetsie
LOGFILE="fleetsie_provisioning_log.txt"
printf "\nprovisioning started on device %s from $PART at %s\n" $HWID "`date`" >> $LOGFILE

## try provision wifi
if [[ ! -f "wifi.txt" ]]; then
    fatal "can't find fleetsie/wifi.txt on USB disk\nfirst line should be the WiFi network name (ESSID), second line should be the WiFi password"
fi
fix_line_endings "wifi.txt"
con=""
{
    while true; do
	if ! read ESSID; then
	    break
	fi
	if ! read PASSWD; then
	    info "wifi.txt is missing a password line for $ESSID"
	    break
	fi
	info "trying nmcli device wifi con \"$ESSID\" password \"$PASSWD\""
	CMD="nmcli device wifi con \"$ESSID\" password \"$PASSWD\""
	read CONRES < <( bash -c "$CMD" 2>&1)
	if [[ "$CONRES" =~ "successfully activated" ]]; then
            info "Connected WiFi to $ESSID"
	    con=1
	    break
	else
            info "Could not connect WiFi to $ESSID; error was $CONRES"
	fi
    done
 } < wifi.txt

if [[ $con != 1 ]]; then
    fatal "unable to connect to any WiFi networks given in wifi.txt"
fi

if ! sqlite3 < /dev/null; then
    info "updating apt and installing sqlite3"
    if ! apt update || ! apt install sqlite3 ; then
	fatalf "unable to install sqlite3"
    fi
fi

## try get ssh keys for fleet server
if [[ ! -f "fleet.txt" ]]; then
    fatal "can't find fleetsie/fleet.txt on USB disk\nfirst line should be fleet server hostname; e.g. whoflewby.org\nsecond line should be fleet name; e.g. ampi\n"
fi
fix_line_endings fleet.txt
{ read FLEETHOST && read FLEETNAME && read FLEETKNOWNHOST; } < fleet.txt
if [[ ! $FLEETHOST ]]; then
	fatal "can't read fleet host name from line 1 of fleetsie/fleet.txt file on USB disk"
fi
if [[ ! $FLEETNAME ]]; then
	fatal "can't read fleet name from line 2 of fleetsie/fleet.txt file on USB disk"
fi

if [[ ! $FLEETKNOWNHOST ]]; then
	fatal "can't read known_hosts line for fleet host from from line 3 of fleetsie/fleet.txt file on USB disk"
fi

DB=provisioning.sqlite
PRIVKEY=id_ed25519_provision_$FLEETNAME
PUBKEY="$PRIVKEY.pub"

if [[ ! -f $PRIVKEY || ! -f $PUBKEY || ! -f $DB ]]; then
    fatal "can't find one or more files needed for connecting to fleet server.\nneed:\n$PRIVKEY\n$PUBKEY\nprovisioning.sqlite\n"
fi

info "appending known_hosts from USB drive to /root/.ssh/known_hosts"
mkdir -p /root/.ssh
echo "$FLEETKNOWNHOST" >> /root/.ssh/known_hosts
cp  $PRIVKEY $PUBKEY /root/.ssh/
chmod u=rw,og=r /root/.ssh/$PUBKEY
chmod u=rw,og= /root/.ssh/$PRIVKEY

# get name of user with id=1000, typically the first non-privileged user.
user1000=`id -nu 1000`

info "sshing to fleet server $FLEETHOST"

REPLY_FILE=/tmp/fleetsieauth.txt
ERROR_FILE=/tmp/fleetsieauth.err
while true; do
    OTP=`sqlite3 $DB "select otp from devices order by id_in_fleet limit 1"`
    if [[ "$OTP" == "" ]]; then
	fatal "no devices left in $DB - contact an administrator for more"
    fi
    if !  printf "%s\n%s\n" "$HWID" "$OTP" | \
	    ssh -T -oStrictHostKeyChecking=true -i /root/.ssh/$PRIVKEY fleetsie_$FLEETNAME@$FLEETHOST \
		> $REPLY_FILE 2> $ERROR_FILE; then
	fatal "error trying to ssh to $FLEETHOST: `cat $ERROR_FILE`"
    fi
    {
	read rv
	case $rv in
	    bad)
		info "server $FLEETHOST reports OTP=$OTP is bad; trying next OTP"
		sqlite3 $DB "delete from devices where otp='$OTP'"
		;;
	    try)
		read DEVNUM
		# server suggests trying device with id_in_fleet = DEVNUM; delete devices with smaller id_in_fleet
		# because the server is effectively telling us they have been claimed.
		sqlite3 $DB "delete from devices where id_in_fleet < $DEVNUM;"
		info "server $FLEETHOST suggests trying device # $DEVNUM"
		;;
	    error)
		read ERRMSG
		fatal "server $FLEETHOST reported this error: $ERRMSG"
		;;
	    ok)
		if ! read HOSTNAME || ! read FLEETUSER || ! read PORT || ! read SRVPUBKEY || ! read SRVPRIVKEY || ! read DEVAUTHKEY ; then
		    fatal "server $FLEETHOST gave bad reply: `cat $REPLY_FILE`"
		fi
		info "setting hostname to $HOSTNAME"
		echo "$HOSTNAME" /etc/hostname
		info "saving ssh keys for access to $HOSTNAME"
		mkdir -p /home/${USER1000}/.ssh
		ln -s "$PORT" /home/${USER1000}/.ssh/fleetsie_tunnel_port
		echo "$SRVPUBKEY" > /home/${USER1000}/.ssh/fleetsie.pub
		echo "$SRVPRIVKEY" > /home/${USER1000}/.ssh/fleetsie
		echo "$FLEETKNOWNHOST" >> /home/${USER1000}/.known_hosts
		echo "$DEVAUTHKEY" >> /home/pi/.ssh/authorized_keys
		cat >> /home/${USER1000}/.ssh/config <<EOF
Host fleetsie
   Hostname $FLEETHOST
   User $FLEETUSER
   StrictHostKeyChecking yes
   IdentityFile ~/.ssh/fleetsie
   IdentitiesOnly yes
EOF
		chown -R ${USER1000}:${USER1000} /home/${USER1000}/.ssh
		chmod oug-r /home/${USER1000}/fleetsie
		chmod og-w -R /home/${USER1000}/.ssh
		if ! ssh -i /home/pi/.ssh/fleetsie fleetsie date > /dev/null 2>/tmp/ssherror.txt; then
		    fatal "could not login to $FLEETHOST with new credentials: `cat /tmp/ssherror.txt`"
		fi
		info "removing entry with this OTP from devices table"
		sqlite3 $DB "delete from devices where otp='$OTP'"
		break
	esac
    } < $REPLY_FILE
done

if [[ -d custom ]]; then
    info "entering customization directory"
    if [[ -f setup ]]; then
	info "running customize/setup"
	if . ./setup 2>/tmp/setuplog.txt; then
	    info "setup completed successfully."
	else
	    info "error while running setup: `cat /tmp/setuplog.txt`"
	fi
    else
	info "no setup script found."
    fi
    if [[ -f overlay.tar.xz ]]; then
	info "extracting overlay.tar.xz to /"
	if tar -C / -xJvf overlay.tar.xz 2>/tmp/overlaylog.txt; then
	    info "overlay extraction completed successfully."
	else
	    info "error while extracting overlay: `cat /tmp/overlaylog.txt`"
	fi
    else
	info "no overlay.tar.xz archive found"
    fi
    if [[ -f cleanup ]]; then
	info "running customize/cleanup"
	if . ./setup 2>/tmp/cleanuplog.txt; then
	    info "cleanup completed successfully."
	else
	    info "error while running cleanup: `cat /tmp/cleanuplog.txt`"
	fi
    else
	info "no cleanup script found."
    fi

else
    info "no customize directory on USB disk; provisioning done."
fi
info "provisioning ended at `date`"
umount $tmp
doneprov
