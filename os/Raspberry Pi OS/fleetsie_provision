#!/bin/bash

# fleetsie_provision: provision this device using files on an attached USB drive

# This script is run from a fleetsie-modified OS image on the Pi during
# the second boot session (i.e. after the first session, which resizes the
# partition etc.)

# Progress is logged:
# - initially, to /home/pi/fleetsie_provision.log
# - once the provisioning USB disk is detected, to USB:/fleetsie/fleetsie_provision.log

# fatal is called for a fatal error.  It writes any supplied arguments
# to $LOGFILE if defined, and then just slowly flash the red LED
function fatal() {
    if [[ "$LOGFILE" ]]; then
	echo "$*" >> $LOGFILE
	printf "Provisioning ended at `date`\n\n" >> $LOGFILE
	say "$* . Provisioning ended at `date`"
	sync
    fi
    sos_leds
}

# on a warning, write any supplied arguments to $LOGFILE, if defined
function warning() {
    if [[ "$LOGFILE" ]]; then
	echo "warning: $*" >> $LOGFILE
	say "warning. $*"
	sync
    fi
}

# write any supplied arguments to $LOGFILE, if defined
function info() {
    if [[ "$LOGFILE" ]]; then
	echo "`date`: $*" >> $LOGFILE
	sync
	say "$*"
    fi
}

# make any line-endings in file $1 just be a single '\n', no '\r'
# as a side effect, clobbers blank lines, which is fine for our purposes.
function fix_line_endings () {
    if [[ -f "$1" ]]; then
	local tmp="`mktemp`"
	cat "$1" | tr -s '\r' '\n' > "$tmp"
	cat "$tmp" > "$1"
	rm "$tmp"
    fi
}

# fix file permissions and ownership on the ~/.ssh for the user passed as $1
function fixup_ssh_perms () {
    if [[ "$1" == "root" ]]; then
	DIR=/root/.ssh
    else
	DIR=/home/$1/.ssh
    fi
    # ensure file ownership is correct
    chown -R $1:$1 $DIR
    # ensure directory permissions are u=rwx, og=rx
    chmod u=rwx,og=rx $DIR
    # ensure authorized_keys permission is u=rw, og=r
    chmod u=rw,og=r $DIR/authorized_keys || true
    # ensure known_hosts permission is u=rw, og=r
    chmod u=rw,og=r $DIR/known_hosts || true
    # ensure config permission is u=rw, og=r
    chmod u=rw,og=r $DIR/config || true
    # ensure public keys are u=rw,og=r and private keys are u=rw,og=
    pushd $DIR
    for pk in *.pub; do
	chmod u=rw,og=r $pk
	chmod u=rw,og= ${pk%.pub}
    done
    popd
}

# use the RPi LEDS (red, green)
RED_LED=/sys/class/leds/PWR/brightness
RED_CTRL=/sys/class/leds/PWR/trigger
GRN_LED=/sys/class/leds/ACT/brightness
GRN_CTRL=/sys/class/leds/ACT/trigger

# init_leds should be called once before calling any other LED
# functions It sets up file descriptors so we don't keep opening the
# LED devices.
function init_leds() {
    exec {RED_LED_FD}>$RED_LED
    exec {GRN_LED_FD}>$GRN_LED
    exec {RED_LED_CTRL_FD}>$RED_CTRL
    exec {GRN_LED_CTRL_FD}>$GRN_CTRL
}

# claim_leds tries to disable other processes from controlling the
# LEDs, so that our settings are definitive.  This is only used at the
# end of provisioning, to leave the Pi with LEDs in a predictable
# blinking pattern informing the user of success or failure
function claim_leds() {
    printf "none\n" >&$GRN_LED_CTRL_FD
    printf "none\n" >&$RED_LED_CTRL_FD
}

# set_leds_for R G TIME sets red LED to R (0 or 1),
# green LED to G (0 or 1) and sleeps for TIME
function set_leds_for() {
    printf "$1\n" >&$RED_LED_FD
    printf "$2\n" >&$GRN_LED_FD
    sleep $3
}

# blink_leds_for R G TIMEON TIMEOFF sets red LED to R (0 or 1),
# green LED to G (0 or 1) and sleeps for TIMEON,
# then sets both LEDS to 0 and sleeps for TIMEOFF
function blink_leds_for() {
    set_leds_for $1 $2 $3
    set_leds_for 0 0 $4
}

# when finished provisioning, blink R+G LEDs
# in tandem
function done_prov() {
    claim_leds
    while true; do
	blink_leds_for 1 1 0.3 0.3
    done
}

# blink red LED in morse code 'dot'
function _dot () {
    blink_leds_for 1 0 0.16 0.16
}

# blink red LED in morse code 'dash'
function _dash () {
    blink_leds_for 1 0 0.5 0.5
}

# blink an SOS pattern in red
function sos_leds () {
    claim_leds
    while true; do
	_dot;  _dot;  _dot
	_dash; _dash; _dash
	_dot;  _dot;  _dot
	sleep 1.5
    done
}

SPOKEN_MESSAGE_FILE=/tmp/spoken_message.wav
SPOKEN_MESSAGE_FILE_TEMP=/tmp/spoken_message_tmp.wav

# init_speech looks for a text-to-speech (tts) program,
# and if one exists, start a task that repeatedly plays
# SPOKEN_MESSAGE_FILE, sleeping 1 s in between.
# It also sets the SPEECH_COMMAND variable used by say(),
# and this serves to flag availability of tts.
function init_speech() {
    # Currently, this only supports pico2wave from package ttspico-utils
    # Hopefully this was installed in the custom_pre stage of provisioning,
    # or was already in the OS image.
    # I find the en-GB voice more clear than the en-US voice.
    if which pico2wave > /dev/null; then
	SPEECH_COMMAND="pico2wave -l en-GB -w $SPOKEN_MESSAGE_FILE_TEMP"
	# run a simple repeating player in the background.  It ends when fleetsie-provision.service stops.
	# No attempt is made to queue multiple speech requests; whenever aplay runs, it plays the latest
	# request to have created SPOKEN_MESSAGE_FILE since last time aplay ran.
	nohup bash -c "while true; do if [[ -f $SPOKEN_MESSAGE_FILE ]]; then aplay $SPOKEN_MESSAGE_FILE; fi; sleep 1; done" &
    fi
}

# say speaks a phrase through the Pi audio jack, if a tts
# service is available.
# If SPEECH_COMMAND is set, that program is used to generate
# SPOKEN_MESSAGE_FILE, which will be spoken through the audio
# jack by the background task launched in init_speech()
function say() {
    if [[ ! "$SPEECH_COMMAND" ]]; then
	return
    fi
    help_pronounce new "$*"
    $SPEECH_COMMAND "$new"
    # (atomically) move the synthesized audio file to its destination
    mv -f $SPOKEN_MESSAGE_FILE_TEMP $SPOKEN_MESSAGE_FILE
}

# get_extra_pronunciations reads the file named in $1
# and uses it to build an associative array called 'pronounciations'.
# Pairs of lines in $1 represent "from" and "to" expressions.
function get_extra_pronunciations () {
    declare -Ag pronunciations
    {
	while true; do
	    if ! read from || ! read to; then
		break
	    fi
	    pronunciations["$from"]="$to"
	done
    } < $1
}

# help_pronounce changes some words to make them easier to pronounce
# clearly for picotts.  It returns the modified words in the variable
# named by $1
function help_pronounce() {
    declare -n v=$1
    shift
    w="$*"
    if [[ "${#pronunciations[@]}" -gt 0 ]]; then
	for from in "${!pronunciations[@]}"; do
	    to="${pronunciations[$from]}"
	    w="${w//$from/$to}"
	done
    fi
    # copy to destination variable
    v="$w"
}

init_leds

# get unique HWID for this device; it is the ethernet adapter MAC address
HWID=`cat /sys/class/net/eth0/address`

# get name of user with id=1000, typically the first non-privileged user.
USER1000=`id -nu 1000`

# initial provisioning log is in home folder on sd card, since
# no USB drive found yet
LOGFILE="/home/$USER1000/fleetsie_provisioning_log.txt"

# perform any pre-customization from /opt/fleetsie
PRE_CUSTOM_DIR=/opt/fleetsie/custom_pre
if [[ -d $PRE_CUSTOM_DIR ]]; then
    pushd $PRE_CUSTOM_DIR
    PRFILE=pronunciation.txt
    if [[ -f $PRFILE ]]; then
	info "Reading extra pronunciations from custom_pre/$PRFILE"
	fix_line_endings $PRFILE
	get_extra_pronunciations $PRFILE
    fi
    info "Starting custom pre-provisioning; any subsequent errors are likely in custom code, and not in fleetsie."
    if [[ -f setup ]]; then
	info "Running customize/setup..."
	if . ./setup 2>/tmp/setuplog.txt; then
	    info "Setup completed successfully."
	else
	    info "error while running setup: `cat /tmp/setuplog.txt`"
	fi
    else
	info "No custom setup script found."
    fi
    if [[ -d packages ]]; then
	pushd packages
	info "Installing custom_pre packages:\n"
	if dpkg -i ./*deb 2>/tmp/packagelog.txt; then
	    info "Successful."
	else
	    info "failed to install packages: `cat /tmp/packagelog.txt`"
	fi
	popd
    else
	info "No custom_pre/packages folder found."
    fi
    # initialize the tts engine here, in case it was just installed from the packages dir.
    init_speech

    if [[ -f overlay.tar.xz ]]; then
	info "Extracting overlay.tar.xz to /..."
	if tar -C / -xJvf overlay.tar.xz 2>/tmp/overlaylog.txt; then
	    info "Overlay extraction completed successfully."
	else
	    info "error while extracting overlay: `cat /tmp/overlaylog.txt`"
	fi
    else
	info "No custom overlay.tar.xz archive found."
    fi
    if [[ -f cleanup ]]; then
	info "Running customize/cleanup..."
	if . ./cleanup 2>/tmp/cleanuplog.txt; then
	    info "Cleanup completed successfully."
	else
	    info "error while running cleanup: `cat /tmp/cleanuplog.txt`"
	fi
    else
	info "No custom cleanup script found."
    fi
    info "Ending custom pre-provisioning."
    popd
else
    info "No $PRE_CUSTOM_DIR found - skipping custom pre-provisioning."
fi

# replace ssh_config, sshd_config with fleetsie versions, if present
for app in ssh sshd; do
    src=/opt/fleetsie/${app}_config
    dst=/etc/ssh/${app}_config
    if [[ -f $src ]]; then
	info "replacing $dst with fleetsie version"
	mv $dst ${dst}_saved_`date -Isecond`
	mv $src $dst
	chown root:root $dst
	chmod u=rw,og=r $dst
    fi
done

# install ssh-tunnel.service
src=/opt/fleetsie/ssh-tunnel.service
dst=/etc/systemd/system/ssh-tunnel.service
if [[ -f "$src" ]]; then
    mv $src $dst
    chown root:root $dst
    chmod oug-x $dst
    systemctl daemon-reload
fi

# do some raspi-config stuff to avoid requiring the user to do it
# in rpi-imager
info "enabling ssh service"

# enable ssh - doing this with "raspi-config nonint do_ssh 1" did not work
touch /boot/firmware/ssh
systemctl start sshswitch.service

#
info "using raspi-config to set the wifi country code to Canada"

# set the wifi country (without this, rfkill blocks use of wifi)
raspi-config nonint do_wifi_country CA

info "waiting for a USB drive with /fleetsie folder to be found or plugged in"
# wait for a USB drive
while true; do
      if grep -E "sda[0-9]?$" /proc/partitions > /dev/null 2>&1; then
      	  break
      fi
      set_leds_for 1 1 0.5
      set_leds_for 0 0 0.5
done

# /tmp/usb will be where we mount the fleetsie provisioning disk,
# unless the system has already done so elsewhere, in which case
# /tmp/usb will be symlinked to it
mounted=""
tmp=/tmp/usb
for PART in `grep -E "sda[0-9]$" /proc/partitions | awk '{print $4}'`; do
    mp=`findmnt -no TARGET $PART`
    if [[ "$mp" ]]; then
	if [[ -d "$mp/fleetsie" ]]; then
	    ln -f -s $mp $tmp
	    mounted=1
	    break
	fi
	continue
    fi
    mkdir $tmp
    if mount /dev/$PART $tmp; then
	## check for fleetsie directory on this partition
	if [[ -d $tmp/fleetsie ]]; then
	    mounted=1
	    break
	else
	    umount $tmp
	    rmdir $tmp
	fi
    fi
done
if [[ ! "$mounted" ]]; then
    fatal
fi
info "found fleetsie directory on /dev/$PART; mounted on $tmp"
info "logging will switch to /fleetsie/fleetsie_provisioning_log.txt on the USB disk"

# remaining operations happen from this directory.  If a new operation
# is added that needs to 'cd', it should instead do 'pushd' and then
# 'popd' when done.
cd $tmp/fleetsie

# switch logging target; this makes it easier to check
# the log, since it's on the USB drive
LOGFILE="$PWD/fleetsie_provisioning_log.txt"
info "Provisioning started on device $HWID from $PART"

# set the temporary password(s) for user 1000 and root
# these will be overwritten by passwords received from
# the server upon registering this device.
PASSWDFILE=password.txt
if [[ -f $PASSWDFILE ]]; then
    info "found file $PASSWDFILE; will try change password for user $USER1000 and root"
    fix_line_endings $PASSWDFILE
    { read password && read password_root; } < $PASSWDFILE
    # default to using the same password for both
    password_root=${password_root:-$password}
    if [[ "$password" != "change-this-password" ]]; then
	echo "$USER1000:$password" | chpasswd
	info "changed password for user $USER1000 to '$password'"
	echo "root:$password_root" | chpasswd
	info "changed password for user root to '$password_root'"
    else
	info "password.txt file has not been editted - the passwords for users root and $USER1000 are left unchanged."
    fi
fi

## try provision wifi
if [[ ! -f "wifi.txt" ]]; then
    fatal "can't find fleetsie/wifi.txt on USB disk\nfirst line should be the WiFi network name (ESSID), second line should be the WiFi password"
fi
fix_line_endings "wifi.txt"
con=""
{
    while true; do
	if ! read ESSID; then
	    break
	fi
	if ! read PASSWD; then
	    info "wifi.txt is missing a password line for $ESSID"
	    break
	fi
	info "trying nmcli device wifi con \"$ESSID\" password \"$PASSWD\""
	CMD="nmcli device wifi con \"$ESSID\" password \"$PASSWD\""
	read CONRES < <( bash -c "$CMD" 2>&1)
	if [[ "$CONRES" =~ "successfully activated" ]]; then
            info "Connected WiFi to $ESSID"
	    con=1
	    break
	else
            info "Could not connect WiFi to $ESSID; error was $CONRES"
	fi
    done
 } < wifi.txt

if [[ $con != 1 ]]; then
    fatal "unable to connect to any WiFi networks given in wifi.txt"
fi

info "waiting for system clock to be synchronized to network time"

systemctl restart systemd-time-wait-sync.service

if ! sqlite3 < /dev/null; then
    info "updating package lists and installing sqlite3"
    if ! apt update || ! apt install sqlite3 ; then
	fatal "unable to install sqlite3"
    fi
fi

# the following follows instructions from here:
#  https://www.zabbix.com/download?zabbix=7.4&os_distribution=raspberry_pi_os&os_version=12&components=agent_2&db=&ws=
#
info "installing zabbix-agent2 and zabbix-sender"
ZBXDEB=zabbix-release_latest_7.4+debian12_all.deb
wget https://repo.zabbix.com/zabbix/7.4/release/raspbian/pool/main/z/zabbix-release/$ZBXDEB
dpkg -i $ZBXDEB
rm $ZBXDEB
apt update
apt install -y zabbix-agent2 zabbix-sender
cp -f /opt/fleetsie/zabbix_agent2.conf /etc/zabbix
cp -f /opt/fleetsie/zabbix_sender.conf /etc/zabbix
mkdir /zabbix
chown zabbix:zabbix /zabbix
# we need a custom zabbix-agent2.service, because the one supplied by
# zabbix doesn't create the required /run/zabbix directory
src=/opt/fleetsie/zabbix-agent2.service
dst=/lib/systemd/system/zabbix-agent2.service
mv $src $dst
chown root:root $dst
chmod og-w $dst
systemctl daemon-reload
systemctl start zabbix-agent2

info "looking for fleet ssh keys in fleet.txt"

## try get ssh keys for fleet server
if [[ ! -f "fleet.txt" ]]; then
    fatal "can't find fleetsie/fleet.txt on USB disk\nfirst line should be fleet server hostname; e.g. whoflewby.org\nsecond line should be fleet name; e.g. ampi\n"
fi
fix_line_endings fleet.txt
{ read FLEETHOST && read FLEETNAME && read FLEETKNOWNHOST; } < fleet.txt
if [[ ! $FLEETHOST ]]; then
	fatal "can't read fleet host name from line 1 of fleetsie/fleet.txt file on USB disk"
fi
if [[ ! $FLEETNAME ]]; then
	fatal "can't read fleet name from line 2 of fleetsie/fleet.txt file on USB disk"
fi

if [[ ! $FLEETKNOWNHOST ]]; then
	fatal "can't read known_hosts line for fleet host from from line 3 of fleetsie/fleet.txt file on USB disk"
fi

DB=provisioning.sqlite
PRIVKEY=id_ed25519_provision_$FLEETNAME
PUBKEY="$PRIVKEY.pub"

if [[ ! -f $PRIVKEY || ! -f $PUBKEY || ! -f $DB ]]; then
    fatal "can't find one or more files needed for connecting to fleet server.\nneed:\n$PRIVKEY\n$PUBKEY\nprovisioning.sqlite\n"
fi

info "Appending known_hosts from USB drive to /root/.ssh/known_hosts"
mkdir -p /root/.ssh
echo "$FLEETKNOWNHOST" >> /root/.ssh/known_hosts
cp  $PRIVKEY $PUBKEY /root/.ssh/
fixup_ssh_perms root

info "sshing to fleet server $FLEETHOST"

REPLY_FILE=/tmp/fleetsieauth.txt
ERROR_FILE=/tmp/fleetsieauth.err

info "Trying to claim an unregistered device:"
while true; do
    OTP=`sqlite3 $DB "select otp from devices order by id_in_fleet limit 1"`
    if [[ "$OTP" == "" ]]; then
	fatal "no devices left in $DB - contact an administrator for more"
    fi
    info " - trying otp=${OTP:0:16}..."
    if !  printf "%s\n%s\n" "$HWID" "$OTP" | \
	    ssh -T -oStrictHostKeyChecking=true -i /root/.ssh/$PRIVKEY fleetsie_$FLEETNAME@$FLEETHOST \
		> $REPLY_FILE 2> $ERROR_FILE; then
	fatal "error trying to ssh to $FLEETHOST: `cat $ERROR_FILE`"
    fi
    {
	read rv
	case $rv in
	    Bad)
		info "server $FLEETHOST reports OTP=$OTP is bad; trying next OTP"
		sqlite3 $DB "delete from devices where otp='$OTP'"
		;;
	    Try)
		read DEVNUM
		# server suggests trying device with id_in_fleet = DEVNUM; delete devices with smaller id_in_fleet
		# because the server is effectively telling us they have been claimed.  Also, delete this OTP,
		# in case server has suggested an earlier one which we don't have (could happen if a previous
		# registration of a different device is manually undone, and OTP is available again).

		sqlite3 $DB "delete from devices where id_in_fleet < $DEVNUM or otp='$OTP';"
		info "server $FLEETHOST suggests trying device with id_in_fleet=$DEVNUM"
		;;
	    Error)
		read ERRMSG
		fatal "server $FLEETHOST reported this error: $ERRMSG"
		;;
            Full)
                fatal "server $FLEETHOST reports there are no available devices allocated to the $FLEETNAME fleet.  Contact an administrator to fix this."
                ;;
	    Ok)
		if ! read USERPWD || ! read ROOTPWD || ! read HOSTNAME || ! read FLEETUSER || ! read PORT || ! read SRVPUBKEY || ! read SRVPRIVKEY || ! read DEVAUTHKEY || ! read ZABBIXPSK; then
		    fatal "server $FLEETHOST gave bad reply: `cat $REPLY_FILE`"
		fi
		info "Successfully claimed!"
		info "Setting hostname to $HOSTNAME"
		echo "$HOSTNAME" > /etc/hostname
		hostname $HOSTNAME
		if [[ "$USERPWD" ]]; then
		    info "Setting server-supplied user password"
		    if ! echo "${USER1000}:$USERPWD" | chpasswd > /tmp/error.txt 2>&1; then
			info "Failed to set user password; error was: `cat /tmp/error.txt`"
		    else
			info "Ok"
		    fi
		fi
		if [[ "$ROOTPWD" ]]; then
		    info "Setting server-supplied root password"
		    if ! echo "root:$ROOTPWD" | chpasswd >/tmp/error.txt 2>&1; then
			info "Failed to set root password; error was: `cat /tmp/error.txt`"
		    else
			info "Ok"
		    fi
		fi
		info "Saving credentials for zabbix_agent2 and zabbix_sender"
		echo "$ZABBIXPSK" > /etc/zabbix/psk.txt
		chmod og-w /etc/zabbix/psk.txt
		sed -i -E -e "/^TLSPSKIdentity=/s/=.*/=$FLEETNAME/" /etc/zabbix/zabbix_agent2.conf
		sed -i -E -e "/^TLSPSKIdentity=/s/=.*/=$FLEETNAME/" /etc/zabbix/zabbix_sender.conf
		info "Saving ssh keys for access to $HOSTNAME and $FLEETHOST"
		mkdir -p /home/${USER1000}/.ssh
		echo "$FLEETKNOWNHOST" >> /home/${USER1000}/.ssh/known_hosts
		ln -s "$PORT" /home/${USER1000}/.ssh/fleetsie_tunnel_port
		echo "$SRVPUBKEY" > /home/${USER1000}/.ssh/fleetsie.pub
		echo -n "$SRVPRIVKEY" | tr ',' '\n' > /home/${USER1000}/.ssh/fleetsie
		echo "$FLEETKNOWNHOST" >> /home/${USER1000}/.known_hosts
		echo "$DEVAUTHKEY" >> /home/${USER1000}/.ssh/authorized_keys
		info "Configuring ssh for logging into fleetsie = $FLEETUSER@$FLEETHOST"
		cat >> /home/${USER1000}/.ssh/config <<EOF
Host fleetsie
   Hostname $FLEETHOST
   User $FLEETUSER
   StrictHostKeyChecking yes
   IdentityFile ~/.ssh/fleetsie
   IdentitiesOnly yes
EOF
		fixup_ssh_perms $USER1000
		if ! systemctl enable --now ssh-tunnel 2>/tmp/error.txt; then
		    warning "there was a problem starting the ssh-tunnel service: `cat /tmp/error.txt`"
		fi
		info "Removing entry with this OTP from devices table"
		sqlite3 $DB "delete from devices where otp='$OTP'"
		break
                ;;
            *) fatal "server $FLEETHOST replied to device claim request with unknown response: `cat $REPLY_FILE`\n`cat $ERROR_FILE`"
                ;;
	esac
    } < $REPLY_FILE
done

SDCARD_POST_PROV_DIR=/opt/fleetsie/custom_post
if [[ -d $SDCARD_POST_PROV_DIR ]]; then
    pushd $SDCARD_POST_PROV_DIR
    info "Starting custom post-provisioning from ${SDCARD_POST_PROV_DIR}.  Subsequent errors are likely in custom code, and not in fleetsie."
    if [[ -f setup ]]; then
	info "Running customize/setup..."
	if . ./setup 2>/tmp/setuplog.txt; then
	    info "Setup completed successfully."
	else
	    info "error while running setup: `cat /tmp/setuplog.txt`"
	fi
    else
	info "No custom setup script found."
    fi
    if [[ -d packages ]]; then
	pushd packages
	info "Installing custom_post packages:\n`ls -1`\n"
	if dpkg -i ./*deb 2>/tmp/packagelog.txt; then
	    info "Successful."
	else
	    info "failed to install packages: `cat /tmp/packagelog.txt`"
	fi
	popd
    else
	info "No custom_pre/packages folder found."
    fi
    if [[ -f overlay.tar.xz ]]; then
	info "Extracting overlay.tar.xz to /..."
	if tar -C / -xJvf overlay.tar.xz 2>/tmp/overlaylog.txt; then
	    info "Overlay extraction completed successfully."
	else
	    info "error while extracting overlay: `cat /tmp/overlaylog.txt`"
	fi
    else
	info "No custom overlay.tar.xz archive found."
    fi
    if [[ -f cleanup ]]; then
	info "Running customize/cleanup..."
	if . ./cleanup 2>/tmp/cleanuplog.txt; then
	    info "Cleanup completed successfully."
	else
	    info "error while running cleanup: `cat /tmp/cleanuplog.txt`"
	fi
    else
	info "No custom cleanup script found."
    fi
    info "Ending custom post-provisioning from SD card."
    popd
else
    info "No custom_post directory on SD card in /opt/fleetsie"
fi

USB_POST_PROV_DIR=$tmp/custom_post
if [[ -d $USB_POST_PROV_DIR ]]; then
    pushd $USB_POST_PROV_DIR
    info "Starting custom post-provisioning from ${USB_POST_PROV_DIR}. Any subsequent errors are likely in custom code, and not in fleetsie."
    if [[ -f setup ]]; then
	info "Running customize/setup..."
	if . ./setup 2>/tmp/setuplog.txt; then
	    info "Setup completed successfully."
	else
	    info "error while running setup: `cat /tmp/setuplog.txt`"
	fi
    else
	info "No custom setup script found."
    fi
    if [[ -d packages ]]; then
	pushd packages
	info "Installing custom_post packages:\n`ls -1`\n"
	if dpkg -i ./*deb 2>/tmp/packagelog.txt; then
	    info "Successful."
	else
	    info "failed to install packages: `cat /tmp/packagelog.txt`"
	fi
	popd
    else
	info "No custom_pre/packages folder found."
    fi
    if [[ -f overlay.tar.xz ]]; then
	info "Extracting overlay.tar.xz to /..."
	if tar -C / -xJvf overlay.tar.xz 2>/tmp/overlaylog.txt; then
	    info "Overlay extraction completed successfully."
	else
	    info "error while extracting overlay: `cat /tmp/overlaylog.txt`"
	fi
    else
	info "No custom overlay.tar.xz archive found."
    fi
    if [[ -f cleanup ]]; then
	info "Running customize/cleanup..."
	if . ./cleanup 2>/tmp/cleanuplog.txt; then
	    info "Cleanup completed successfully."
	else
	    info "error while running cleanup: `cat /tmp/cleanuplog.txt`"
	fi
    else
	info "No custom cleanup script found."
    fi
    info "Ending custom post-provisioning from USB disk."
    popd
else
    info "No custom_post directory on USB disk."
fi
if [[ ! -L $tmp ]]; then
    umount $tmp
fi
info "Provisioning ended at `date`."

# Put the final message on a loop.  The provisioner needs to hear the
# host ID spelled out clearly, so they can write it on a physical
# label.  We separate the letters by commas and replace "-" with "dash",
# which seems to work well with pico2wave.
CLEAR_HOSTNAME=`echo $HOSTNAME | sed -E -e 's/(.)/\1, /g;s/-/dash/g'`

say "Provisioning complete.  \
You can safely remove the USB disk and reboot without it. \
This raspberry pi is now ready to deploy as part of the $FLEET_NAME fleet. \
Please attach a label to it with this code. $CLEAR_HOSTNAME"

systemctl disable fleetsie-provision
done_prov
