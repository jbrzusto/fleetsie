#!/bin/bash

# fleetsie_gen_server - allocate new devices for a fleet

function usage() {
    cat <<EOF
Usage:

fleetsie_gen_server NUM FLEETNAME

- add NUM new devices to fleet FLEETNAME

fleetsie_gen_server is the server-side script called by fleetsie_gen (which runs on a user's PC).
It is run as user fleetsie on the server when fleetsie_gen is run on the user's PC.
It is *NOT* safe for concurrent use.

Several databases are used:

  - Master: /home/fleetsie/fleets.sqlite - all new devices are
            allocated here, and eventually, their registration to a
            hardware device is reflected here.

  - Fleet: /home/fleetsie_FLEETNAME/fleet.sqlite - new devices are copied
           here from Master.  This DB is used by fleetsieauth when a device is
 	   being provisioned, and is the first place where the (HWID, device) pairing
 	   is made (i.e. the device is registered).

  - Provisioning: /home/fleetsie_FLEETNAME/provisioning.sqlite - a reduced version
    of the Fleet database, with only the OTP and index_in_fleet columns.  Rows
    represent allocated but unregistered devices for this fleet.  This is
    updated whenever new devices are allocated to the fleet, or when devices are
    registered.  This database is copied to the USB provisioning disk by fleetsie_gen,
    and is used by a device that is provisioning itself.

fleetsie_gen_server does these things:

- if user fleetsie_FLEETNAME does not exist, creates it.

- if NUM > 0, N new devices are allocated to fleet FLEETNAME (provided there are enough TCP ports remaining),
  and these are appended to the Master, Fleet, and Provisioning databases.

- regardless of NUM, update the Master database with any new registrations from the fleet database

EOF
    exit $1
}

# sqlite runs a set of queries through the sqlite database named in DB
# The first line of output is saved in the variable whose name is
# provided as $1; remaining parameters are the db querie(s).  We use
# pragma busy_timeout to allow for retries of a locked database.  This
# prints the timeout value, so we read and skip that.
function sqlite() {
    declare -n v=$1
    shift
    read v < <( sqlite3 $DB "$*" )
}

# Set the range of TCP ports that fleetsie can assign for mapping back to device SSH server ports.
# All devices in all fleets on this server are allocated a unique port in this range.
MIN_TCP_PORT=20000
MAX_TCP_PORT=29999

# Note: the fleet server should be kept from using these ports when creating new TCP connections
# Typically, a linux box shows this:
#    $ cat /proc/sys/net/ipv4/ip_local_port_range
#    32768	60999
# which means ports in the range 20000-29999 won't be used as ephemeral ports for outgoing connections,
# so should be available for ssh to map.
# If necessary, the file /etc/sysctl.d/fleetsie can be created on the server, with this line:
#  net.ipv4.ip_local_port_range=32768 60999
# to keep the range away from 20000-29999.

NUM="$1"
if [[ ! "$NUM" =~ ^[0-9]+$ ]]; then
    usage
fi
shift
FLEETNAME="$1"
if [[ ! "$FLEETNAME" =~ ^[-_[:alnum:]]+$ ]]; then
    usage
fi

FLEETUSER="fleetsie_$FLEETNAME"
if [[ ! if id -u test 2> /dev/null ]] ; then
    # we set the shell to be a program that maintains a structure in /run that reflects which devices are connected
    sudo adduser --disabled-password --gecos '""' --ingroup fleetsie --shell /home/fleetsie/fleetsie_login $FLEETUSER
fi

FLEETDIR=/home/$FLEETUSER

MASTERDB="/home/fleetsie/fleets.sqlite"
FLEETDB="$FLEETDIR/fleet.sqlite"
PROVISIONINGDB="$FLEETDIR/provisioning.sqlite"

# create MASTER and FLEET DBs if they don't exist
for DB in "$MASTERDB" "$FLEETDB"; do
    if [[ -f $DB ]]; then
	continue
    fi
    cat | sqlite3 $DB <<EOF
CREATE TABLE devices (
     id INTEGER UNIQUE PRIMARY KEY NOT NULL,  -- unique ID for device, across all fleets
     fleet VARCHAR NOT NULL,                  -- name of fleet device belongs to
     id_in_fleet INTEGER NOT NULL,            -- unique ID for device within fleet
     fleetuser VARCHAR NOT NULL,              -- name of user device uses for ssh to fleet server; typically, fleetsie_FLEET
     hostname VARCHAR NOT NULL,               -- hostname for device; typically FLEET-ID_IN_FLEET
     hwid VARCHAR,                            -- hardware ID of device; NULL means no device registered to this record yet
     otp VARCHAR NOT NULL,                    -- one-time password used by device to register
     ts_generated DOUBLE NOT NULL,            -- unix timestamp for when this device record was generated
     ts_registered DOUBLE,                    -- unix timestamp for when this device was registered; NULL means not registered yet
     tunnel_port INTEGER NOT NULL,            -- TCP port mapped on server back to device SSH server port
     device_public_key VARCHAR NOT NULL,      -- public key which can be used to login as user 1000 on device
     device_private_key VARCHAR NOT NULL,     -- private key which can be used to login as user 1000 on device
     server_public_key VARCHAR NOT NULL,      -- public key which device will use to ssh into fleet server
     server_private_key VARCHAR NOT NULL,     -- private key which device will use to ssh into fleet server
     ip_provisioned_from VARCHAR NOT NULL     -- IP address from which request to provision this device originated
 );
CREATE UNIQUE INDEX devices_hwid ON devices(hwid);
CREATE UNIQUE INDEX devices_fleet_otp_hwid ON devices(fleet, otp, hwid);
CREATE UNIQUE INDEX devices_fleet_id_in_fleet ON devices(fleet, id_in_fleet);
EOF
done

# create PROVISIONING DB if it doesn't exist
if [[ ! -f "$PROVISIONINGDB" ]]; then
    cat | sqlite3 $PROVISIONINGDB <<EOF
CREATE TABLE devices (
     id_in_fleet INTEGER UNIQUE PRIMARY KEY NOT NULL, -- unique ID for device within fleet
     otp VARCHAR NOT NULL,                            -- one-time password used to register as this device
 );
EOF
DB="$MASTERDB"

# get max id used
sqlite next_id "select 1 + max(id) from devices"

# get max port used
sqlite next_port "select 1 + max(tunnel_port) from devices"
if [[ "$next_port" == "" ]]; then
    next_port=$MIN_TCP_PORT
fi

# get max id used in fleet
sqlite max_id_in_fleet "select 1 + max(id_in_fleet) from devices where fleet='$FLEETNAME'"
if [[ "$next_id_in_fleet" == "" ]]; then
    next_id_in_fleet=1
fi

# generate one device at a time
while [[ $NUM -gt 0 ]]; do
    if [[ $next_port -gt MAX_TCP_PORT ]]; then
	printf "error: no more TCP ports left - quitting.\n"
	exit 1
    fi
    HOSTNAME=${FLEETNAME}-$next_id_in_fleet
    # generate keys for logging into the server from the device
    srv_ssh_key_file=$FLEETDIR/.ssh/id_ed25519_$HOSTNAME
    ssh-keygen -P "" -t ed25519 -f $srv_ssh_key_file
    SRVPRIVKEY=`cat $srv_ssh_key_file`
    SRVPUBKEY=`cat ${srv_ssh_key_file}.pub`
    # generate keys for logging into the device from the server
    dev_ssh_key_file=$FLEETDIR/.ssh/id_ed25519_${HOSTNAME}_dev
    ssh-keygen -P "" -t ed25519 -f $dev_ssh_key_file
    DEVPRIVKEY=`cat $dev_ssh_key_file`
    DEVPUBKEY=`cat ${dev_ssh_key_file}.pub`
    OTP=`od -N 128 -w256 -t x1 -A none /dev/urandom | tr -d ' '`
    TS_GEN=`date +%s`
    DB=MASTERDB
    sqlite resp "insert into devices(id, fleet, id_in_fleet, fleetuser, hostname, otp, ts_generated, tunnel_port, device_public_key, device_private_key, server_public_key, server_private_key) values(next_id, '$FLEETNAME', $next_id_in_fleet, '$FLEETUSER', '$HOSTNAME', '$OTP', '$TS_GEN', '$next_port','$DEVPUBKEY', '$DEVPRIVKEY', '$SRVPUBKEY', '$SRVPRIVKEY');"
    DB=FLEETDB
    sqlite resp "insert into devices(id, fleet, id_in_fleet, fleetuser, hostname, otp, ts_generated, tunnel_port, device_public_key, device_private_key, server_public_key, server_private_key) values(next_id, '$FLEETNAME', $next_id_in_fleet, '$FLEETUSER', '$HOSTNAME', '$OTP', '$TS_GEN', '$next_port','$DEVPUBKEY', '$DEVPRIVKEY', '$SRVPUBKEY', '$SRVPRIVKEY');"
    DB=PROVISIONINGDB
    sqlite resp "insert into devices(id_in_fleet, otp) values($next_id_in_fleet, '$OTP');"
    next_id_in_fleet=$(( $next_id_in_fleet + 1 ))
    next_port=$(( $next_port + 1 ))
    next_id=$(( $next_id + 1 ))
    printf "Generated device %s\n" $HOSTNAME
done

# update Master DB with registrations from Fleet DB
DB=MASTERDB
sqlite resp "attach database '$FLEETDB' as 'db1'; update devices set hwid=reg.hwid, ts_registered=reg.ts_registered, ip_provisioned_from=reg.ip_provisoned_from from (select id, hwid, ts_provisioned, ip_provisioned_from from db1.devices where hwid is not null and fleet='$FLEETNAME') as reg where id=reg.id and hwid is null)"
