#!/bin/bash

# fleetsie_gen_server - allocate new devices for a fleet

function usage() {
    cat <<EOF
Usage:

fleetsie_gen_server NUM FLEETNAME

- add NUM new devices to fleet FLEETNAME

fleetsie_gen_server is the server-side script called by fleetsie_gen (which runs on a user's PC).
It is run as user fleetsie on the server when fleetsie_gen is run on the user's PC.
It is *NOT* safe for concurrent use.

Several databases are used:

  - Main: /home/fleetsie/fleets.sqlite - all new devices are
          allocated here, and eventually, their registration to a
          hardware device is reflected here.

  - Fleet: /home/fleetsie/fleets/FLEETNAME/fleet.sqlite - new devices are copied
           here from Main.  This DB is used by fleetsieauth when a device is
 	   being provisioned, and is the first place where the (HWID, device) pairing
 	   is made (i.e. the device is registered).  This DB is owned by user
	   fleetsie_FLEETNAME

  - Provisioning: /home/fleetsie/fleets/FLEETNAME/provisioning.sqlite - a reduced version
    of the Fleet database, with only the OTP and index_in_fleet columns.  Rows
    represent allocated but unregistered devices for this fleet.  This is
    updated whenever new devices are allocated to the fleet, or when devices are
    registered.  This database is copied to the USB provisioning disk by fleetsie_gen,
    and is used by a device that is provisioning itself.

fleetsie_gen_server does these things:

- if user fleetsie_FLEETNAME does not exist, creates it.

- if NUM > 0, N new devices are allocated to fleet FLEETNAME (provided there are enough TCP ports remaining),
  and these are appended to the Main, Fleet, and Provisioning databases.

- regardless of NUM, update the Main database with any new registrations from the Fleet database

EOF
    exit $1
}

# sqlite runs a set of queries through the sqlite database named in DB
# The first line of output is saved in the variable whose name is
# provided as $1; remaining parameters are the db querie(s).  We use
# pragma busy_timeout to allow for retries of a locked database.  This
# prints the timeout value, so we read and skip that.
function sqlite() {
    declare -n v=$1
    shift
    read v < <( sqlite3 $DB "$*" )
}

# sqlite_do runs a non-select query on the sqlite database DB and
# prints any output
function sqlite_do() {
    sqlite3 $DB "$*"
}

# Set the range of TCP ports that fleetsie can assign for mapping back to device SSH server ports.
# All devices in all fleets on this server are allocated a unique port in this range.
MIN_TCP_PORT=20001
MAX_TCP_PORT=29999

# Note: the fleet server should be kept from using these ports when creating new TCP connections
# Typically, a linux box shows this:
#    $ cat /proc/sys/net/ipv4/ip_local_port_range
#    32768	60999
# which means ports in the range 20000-29999 won't be used as ephemeral ports for outgoing connections,
# so should be available for ssh to map.
# If necessary, the file /etc/sysctl.d/fleetsie can be created on the server, with this line:
#  net.ipv4.ip_local_port_range=32768 60999
# to keep the range away from 20000-29999.

NUM="$1"
if [[ ! "$NUM" =~ ^[0-9]+$ ]]; then
    usage
fi
shift
FLEETNAME="$1"
if [[ ! "$FLEETNAME" =~ ^[-_[:alnum:]]+$ ]]; then
    usage
fi

FLEETUSER="fleetsie_$FLEETNAME"
FLEETDIR=/home/$FLEETUSER
FLEETSUBDIR=/home/fleetsie/fleets/$FLEETNAME
if ! id -u $FLEETUSER 2> /dev/null ; then
    printf "Creating user $FLEETUSER...\n"
    sudo adduser --disabled-password --gecos '""' $FLEETUSER
    # add the group for new user to groups for user fleetsie
    sudo usermod -a -G $FLEETUSER fleetsie
    sudo mkdir $FLEETDIR/.ssh
    sudo touch $FLEETDIR/.ssh/authorized_keys
    sudo mkdir -p $FLEETSUBDIR
    sudo chmod g+w $FLEETSUBDIR
    sudo chown fleetsie:fleetsie /home/fleetsie/fleets
    sudo chown $FLEETUSER:$FLEETUSER $FLEETSUBDIR
    # generate fleet credentials used by devices when first connecting
    # to the server.  These keys are provided on the USB provisioning
    # disk, and can only be used to run fleetsie_auth, which provides
    # device credentials upon receipt of a valid, unused one-time
    # password.
    PROV_KEY_FILE=$FLEETDIR/.ssh/id_ed25519_provision_$FLEETNAME
    sudo ssh-keygen -P "" -t ed25519 -C "fleetsie_$FLEETNAME@`hostname`" -f $PROV_KEY_FILE > /dev/null
    sudo chown $FLEETUSER:$FLEETUSER $PROV_KEY_FILE ${PROV_KEY_FILE}.pub
    # place copies in ~/fleetsie/.ssh/ for convenience
    sudo cp $PROV_KEY_FILE ${PROV_KEY_FILE}.pub $FLEETSUBDIR
    sudo chown fleetsie:fleetsie_$FLEETNAME $FLEETSUBDIR/`basename $PROV_KEY_FILE`*
    # build the authorized_keys entry for the fleet credentials
    FLEETPUBKEY=`sudo cat ${PROV_KEY_FILE}.pub`
    AUTHKEYPREFIX="command=\"/home/fleetsie/fleetsie_auth\",restrict,pty,environment=\"FLEET=$FLEETNAME\""
    printf "%s %s\n" "$AUTHKEYPREFIX" "$FLEETPUBKEY" | sudo tee -a $FLEETDIR/.ssh/authorized_keys > /dev/null
    sudo chown -R $FLEETUSER:$FLEETUSER $FLEETDIR/.ssh
    # create a boot-time cron job to build the skeleton directories for the fleet in /run/fleetsie
    printf "@reboot root /bin/bash -c 'mkdir -p /run/fleetsie/dev/$FLEETNAME && chown $FLEETUSER:$FLEETUSER /run/fleetsie/dev/$FLEETNAME'\n" | sudo tee /etc/cron.d/${FLEETUSER}_boot > /dev/null
    # The rest of the code in this file assumes that the fleetsie user belongs to group fleetsie_FLEETNAME.
    # It has been added above, but this doesn't take effect until a new login, so return an error,
    # which will cause the client-side to re-login and re-run this script.
    # (sure, we could instead use sudo all over the place below, but this seems cleaner)
    printf "New user $FLEETUSER created; fleetsie_gen_server being re-run.\n"
    exit 1
fi

FLEETDIR=/home/$FLEETUSER

MAINDB="/home/fleetsie/fleets.sqlite"
FLEETDB="$FLEETSUBDIR/fleet.sqlite"
PROVISIONINGDB="$FLEETSUBDIR/provisioning.sqlite"

# create MAIN and FLEET DBs if they don't exist
for DB in "$MAINDB" "$FLEETDB"; do
    if [[ -f $DB ]]; then
	continue
    fi
    printf "Creating database $DB...\n"
    sqlite_do '
CREATE TABLE devices (
     id INTEGER UNIQUE PRIMARY KEY NOT NULL,  -- unique ID for device, across all fleets
     fleet VARCHAR NOT NULL,                  -- name of fleet device belongs to
     id_in_fleet INTEGER NOT NULL,            -- unique ID for device within fleet
     fleetuser VARCHAR NOT NULL,              -- name of user device uses for ssh to fleet server; typically, fleetsie_FLEET
     hostname VARCHAR NOT NULL,               -- hostname for device; typically FLEET-ID_IN_FLEET
     hwid VARCHAR,                            -- hardware ID of device; NULL means no device registered to this record yet
     otp VARCHAR NOT NULL,                    -- one-time password used by device to register
     ts_generated DOUBLE NOT NULL,            -- unix timestamp for when this device record was generated
     ts_registered DOUBLE,                    -- unix timestamp for when this device was registered; NULL means not registered yet
     tunnel_port INTEGER NOT NULL,            -- TCP port mapped on server back to device SSH server port
     user_pwd VARCHAR,                        -- plaintext password for user 1000 on device (yes, should be stored hashed, not plaintext!)
     root_pwd VARCHAR,                        -- plaintext password for root user on device (yes, should be stored hashed, not plaintext!)
     device_public_key VARCHAR NOT NULL,      -- public key which can be used to login as user 1000 on device
     device_private_key VARCHAR NOT NULL,     -- private key which can be used to login as user 1000 on device
     server_public_key VARCHAR NOT NULL,      -- public key which device will use to ssh into fleet server
     server_private_key VARCHAR NOT NULL,     -- private key which device will use to ssh into fleet server
     ip_provisioned_from VARCHAR              -- IP address from which request to provision this device originated
 );
CREATE UNIQUE INDEX devices_hwid ON devices(hwid);
CREATE UNIQUE INDEX devices_fleet_otp_hwid ON devices(fleet, otp, hwid);
CREATE UNIQUE INDEX devices_fleet_id_in_fleet ON devices(fleet, id_in_fleet);
'
    if [[ "$DB" == "$FLEETDB" ]]; then
	sudo chown $FLEETUSER:$FLEETUSER $DB
	sudo chmod g+w $DB
    else
	# in the main DB, generate a new zabbix Pre-shared Key for the fleet
	sqlite_do '
CREATE TABLE IF NOT EXISTS zabbix_fleet_psk (
     fleet VARCHAR UNIQUE PRIMARY KEY NOT NULL,
     zabbix_psk VARCHAR NOT NULL
);
'
	# generate a 256-bit zabbix PSK
	FLEET_ZABBIX_PSK=`od -N 32 -w128 -t x1 -A none /dev/urandom | tr -d ' '`
	sqlite_do "INSERT INTO zabbix_fleet_psk(fleet, zabbix_psk) VALUES ('$FLEETNAME','$FLEET_ZABBIX_PSK');"

	FLEET_PSK_FILE=/etc/zabbix/psk_${FLEETNAME}.txt
	echo "$FLEET_ZABBIX_PSK" | sudo tee $FLEET_PSK_FILE > /dev/null
	sudo cp /etc/zabbix/zabbix_sender.conf /etc/zabbix/zabbix_sender_${FLEETNAME}.conf
	sudo sed -i -e "/^TLSPSKIdentity=/s/=.*/$FLEET_NAME"
	sudo sed -i -e "/^TLSPSKFile=/s/=.*/$FLEET_PSK_FILE"
    fi
done

# create PROVISIONING DB if it doesn't exist
DB="$PROVISIONINGDB"
if [[ ! -f "$DB" ]]; then
    printf "Creating provisioning database for fleet $FLEETNAME...\n"
    sqlite_do '
CREATE TABLE devices (
     id_in_fleet INTEGER UNIQUE PRIMARY KEY NOT NULL, -- unique ID for device within fleet
     otp VARCHAR NOT NULL                             -- one-time password used to register as this device
 );
'
    sudo chown $FLEETUSER:$FLEETUSER $DB
    sudo chmod g+w $DB
fi
DB="$MAINDB"

# get max id used
sqlite next_id "select 1 + max(id) from devices"
if [[ "$next_id" == "" ]]; then
    next_id=1
fi

# get max port used
sqlite next_port "select 1 + max(tunnel_port) from devices"
if [[ "$next_port" == "" ]]; then
    next_port=$MIN_TCP_PORT
fi

# get max id used in fleet
sqlite next_id_in_fleet "select 1 + max(id_in_fleet) from devices where fleet='$FLEETNAME'"
if [[ "$next_id_in_fleet" == "" ]]; then
    next_id_in_fleet=1
fi

# generate one device at a time
while [[ $NUM -gt 0 ]]; do
    if [[ $next_port -gt MAX_TCP_PORT ]]; then
	printf "error: no more TCP ports left - quitting.\n"
	exit 1
    fi
    HOSTNAME=${FLEETNAME}-$next_id_in_fleet
    # generate keys for logging into the server from the device
    srv_ssh_key_file=$FLEETDIR/.ssh/id_ed25519_$HOSTNAME
    sudo ssh-keygen -P "" -t ed25519 -C "fleetsie_$FLEETNAME@`hostname`" -f $srv_ssh_key_file > /dev/null
    sudo chown $FLEETUSER:$FLEETUSER $srv_ssh_key_file $srv_ssh_key_file.pub
    SRVPRIVKEY=`sudo cat $srv_ssh_key_file`
    SRVPUBKEY=`sudo cat ${srv_ssh_key_file}.pub`
    AUTHKEYPREFIX="command=\"/usr/bin/setsid -w /home/fleetsie/fleetsie_login\",environment=\"FLEETSIE_FLEET=$FLEETNAME\",environment=\"FLEETSIE_HOST=$HOSTNAME\",environment=\"FLEETSIE_PORT=$next_port\",restrict,pty,permitlisten=\"localhost:$next_port\",permitopen=\"localhost:10051\""
    printf "%s %s\n" "$AUTHKEYPREFIX" "$SRVPUBKEY" | sudo tee -a $FLEETDIR/.ssh/authorized_keys > /dev/null
    # generate keys for logging into the device from the server
    dev_ssh_key_file=$FLEETDIR/.ssh/id_ed25519_${HOSTNAME}_dev
    sudo ssh-keygen -P "" -t ed25519 -C "`hostname`@$HOSTNAME" -f $dev_ssh_key_file  > /dev/null
    sudo chown $FLEETUSER:$FLEETUSER $dev_ssh_key_file $dev_ssh_key_file.pub
    DEVPRIVKEY=`sudo cat $dev_ssh_key_file`
    DEVPUBKEY=`sudo cat ${dev_ssh_key_file}.pub`
    OTP=`od -N 128 -w256 -t x1 -A none /dev/urandom | tr -d ' '`
    DB="$MAINDB"
    sqlite_do "insert into devices(id, fleet, id_in_fleet, fleetuser, hostname, otp, ts_generated, tunnel_port, device_public_key, device_private_key, server_public_key, server_private_key) values($next_id, '$FLEETNAME', $next_id_in_fleet, '$FLEETUSER', '$HOSTNAME', '$OTP', strftime('%s',datetime()), '$next_port','$DEVPUBKEY', '$DEVPRIVKEY', '$SRVPUBKEY', '$SRVPRIVKEY');"
    DB="$FLEETDB"
    sqlite_do "insert into devices(id, fleet, id_in_fleet, fleetuser, hostname, otp, ts_generated, tunnel_port, device_public_key, device_private_key, server_public_key, server_private_key) values($next_id, '$FLEETNAME', $next_id_in_fleet, '$FLEETUSER', '$HOSTNAME', '$OTP',  strftime('%s',datetime()), '$next_port','$DEVPUBKEY', '$DEVPRIVKEY', '$SRVPUBKEY', '$SRVPRIVKEY');"
    DB="$PROVISIONINGDB"
    sqlite_do "insert into devices(id_in_fleet, otp) values($next_id_in_fleet, '$OTP');"
    next_id_in_fleet=$(( $next_id_in_fleet + 1 ))
    next_port=$(( $next_port + 1 ))
    next_id=$(( $next_id + 1 ))
    printf "Generated device %s\n" $HOSTNAME
    NUM=$(( $NUM - 1 ))
done

# update Main DB with registrations from Fleet DB
DB="$MAINDB"
sqlite_do "
attach database '$FLEETDB' as 'db1';
update devices set
  hwid=reg.hwid,
  ts_registered=reg.ts_registered,
  ip_provisioned_from=reg.ip_provisioned_from
from (
  select id, hwid, ts_registered, ip_provisioned_from
  from db1.devices
  where hwid is not null and fleet='$FLEETNAME') as reg
where devices.id=reg.id and devices.hwid is null
"
